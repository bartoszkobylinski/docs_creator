[
  {
    "module": "logger_config",
    "qualname": "setup_loggers",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n\n    info_logger = logging.getLogger('info_logger')\n    error_logger = logging.getLogger('error_logger')\n",
    "lineno": 5,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/logger_config.py",
    "full_source": "def setup_loggers():\n    timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n\n    info_logger = logging.getLogger('info_logger')\n    error_logger = logging.getLogger('error_logger')\n\n    info_logger.setLevel(logging.INFO)\n    error_logger.setLevel(logging.DEBUG)\n\n    info_log_filename = f\"info_logger_{timestamp}.log\"\n    error_log_filename = f\"error_logger_{timestamp}.log\"\n\n    info_handler = logging.FileHandler(info_log_filename)\n    error_handler = logging.FileHandler(error_log_filename)\n\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    info_handler.setFormatter(formatter)\n    error_handler.setFormatter(formatter)\n\n    info_logger.addHandler(info_handler)\n    error_logger.addHandler(error_handler)\n\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    info_logger.addHandler(console_handler)\n    error_logger.addHandler(console_handler)\n\n    return info_logger, error_logger",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater",
    "path": "",
    "method": "CLASS",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 28,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "class PlayerUpdater:\n    UPCOMING_MATCHES_URL: str = 'https://api.pandascore.co/csgo/matches/upcoming'\n    REQUEST_COUNTER: int = 0\n\n    def __init__(self, api_token: str, user: str, password: str, host: str, port: str, db_name: str) -> None:\n        self.headers = {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_token}\"\n        }\n        self.database_manager = DatabaseManager(user=user, password=password, host=host, port=port, db_name=db_name)\n\n    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))\n    def make_request(self, url: str, params: Optional[Dict] = None) -> requests.Response:\n        response = requests.get(url=url, headers=self.headers, params=params, timeout=10)\n        time.sleep(0.4)\n        PlayerUpdater.REQUEST_COUNTER += 1\n        response.raise_for_status()\n        info_logger.info(f\"Total requests made to Pandascore API: {PlayerUpdater.REQUEST_COUNTER}. I've hit url: {url}\")\n        return response\n\n    def get_upcoming_matches(self) -> List[Dict]:\n        params = {\n            \"filter[future]\": \"true\",\n            \"sort\": \"begin_at\",\n            \"per_page\": 100,\n            \"page\": 1\n        }\n        all_upcoming_matches: List[Dict] = []\n        while True:\n            try:\n                response = self.make_request(self.UPCOMING_MATCHES_URL, params=params)\n                matches = response.json()\n                if not matches:\n                    break\n                all_upcoming_matches.extend(matches)\n                info_logger.info(f\"Fetched {len(matches)} matches on page {params['page']}\")\n                params['page'] += 1\n            except requests.exceptions.RequestException as req_exception:\n                error_logger.error(f\"Error fetching upcoming matches on page {params['page']}: {req_exception}\")\n        info_logger.info(f\"Total matches fetched: {len(all_upcoming_matches)}\")\n        return all_upcoming_matches\n\n    def get_particular_team_url(self, team_id: int) -> str:\n        return f'https://api.pandascore.co/teams/{team_id}'\n\n    def get_particular_player_stats_url(self, player_id: int) -> str:\n        return f\"https://api.pandascore.co/csgo/players/{player_id}/stats\"\n\n    def get_particular_game_stats_url(self, game_id: int) -> str:\n        return f'https://api.pandascore.co/csgo/games/{game_id}'\n\n    def get_required_matches_for_particular_player(self, player_id: int, required_amount_of_matches: int) -> str:\n        return f\"https://api.pandascore.co/players/{player_id}/matches?per_page{required_amount_of_matches}&sort=-modified_at\"\n\n    def compare_and_update(self, existing_data: object, new_data: Dict) -> bool:\n        updated = False\n        for key, value in new_data.items():\n            if getattr(existing_data, key) != value:\n                setattr(existing_data, key, value)\n                updated = True\n        return updated\n\n    def fetch_last_games(self, player_id: int, total_games: int = 70) -> List[int]:\n        games_collected: List[int] = []\n        page = 1\n\n        while len(games_collected) < total_games:\n            matches_url = self.get_required_matches_for_particular_player(player_id,\n                                                                          required_amount_of_matches=total_games)\n            try:\n                response = self.make_request(url=matches_url)\n                matches = response.json()\n                if not matches:\n                    error_logger.error(f\"No matches found for player {player_id} on page {page}\")\n                    break\n\n                for match in matches:\n                    games = match.get('games', [])\n                    if games is None:\n                        error_logger.error(f\"No games data found in match for player {player_id}. Match data: {match}\")\n                        continue\n                    for game in games:\n                        game_id = game.get('id')\n                        if game_id:\n                            games_collected.append(game_id)\n                            if len(games_collected) >= total_games:\n                                break\n                    if len(games_collected) >= total_games:\n                        break\n\n                if len(games_collected) >= total_games:\n                    break\n\n            except requests.exceptions.RequestException as req_exception:\n                error_logger.error(\n                    f\"RequestException occurred while fetching data for player {player_id}: {req_exception}\")\n                break\n            except ValueError as val_err:\n                error_logger.error(\n                    f\"ValueError occurred while processing JSON response for player {player_id}: {val_err}\")\n                break\n            except KeyError as key_err:\n                error_logger.error(\n                    f\"KeyError occurred while fetching games for player {player_id}: {key_err}. Response: {response.text}\")\n                break\n            except Exception as e:\n                error_logger.error(f\"An unexpected error occurred while fetching games for player {player_id}: {e}\")\n                break\n\n            page += 1\n\n        print(f\"games_collected: {len(games_collected)}\")\n        return games_collected[:total_games]\n\n    def populate_leagues(self, session: Session, league_data: Dict) -> Optional[League]:\n\n        league_id: int = league_data.get('id')\n        is_created = False\n\n        try:\n            league = session.query(League).filter_by(league_id=league_id).one_or_none()\n\n            if league is None:\n                league = League(league_id=league_id)\n                is_created = True\n\n            new_data = {\n                'image_url': league_data.get('image_url'),\n                'modified_at': league_data.get('modified_at'),\n                'name': league_data.get('name'),\n                'slug': league_data.get('slug'),\n                'url': league_data.get('url')\n            }\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(league, key, value)\n                session.add(league)\n                session.commit()\n                info_logger.info(f\"New league {league_id} created.\")\n            else:\n                if self.compare_and_update(league, new_data):\n                    session.commit()\n                    info_logger.info(f\"League {league_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing league {league_id}, no updates performed.\")\n\n            return league\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate league {league_id}. Error: {str(error)}\")\n            for key, value in league_data.items():\n                error_logger.error(f\"{key}: {value}\")\n\n            raise\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing league {league_id}. Error: {str(exception)}\")\n\n    def populate_series(self, session: Session, series_data: Dict) -> Optional[Serie]:\n        serie_id: int = series_data.get('id')\n        is_created = False\n\n        try:\n            serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n\n            if serie is None:\n                serie = Serie(serie_id=serie_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': series_data.get('begin_at'),\n                'end_at': series_data.get('end_at'),\n                'full_name': series_data.get('full_name'),\n                'league_id': series_data.get('league_id'),\n                'modified_at': series_data.get('modified_at'),\n                'name': series_data.get('name'),\n                'season': series_data.get('season'),\n                'slug': series_data.get('slug'),\n                'winner_id': series_data.get('winner_id'),\n                'winner_type': series_data.get('winner_type'),\n                'year': series_data.get('year')\n            }\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(serie, key, value)\n                session.add(serie)\n                session.commit()\n                info_logger.info(f\"New series {serie_id} created.\")\n            else:\n                if self.compare_and_update(serie, new_data):\n                    session.commit()\n                    info_logger.info(f\"Series {serie_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing series {serie_id} found, no updates performed.\")\n\n            return serie\n\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate series {serie_id}. Error: {str(error)}\")\n            for key, value in series_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing series {serie_id}: {str(exception)}\")\n            raise\n\n    def populate_tournament(self, session: Session, match_data: Dict) -> Optional[Tournament]:\n        tournament_id: int = match_data.get('tournament').get('id')\n        tournament_data = match_data.get('tournament')\n        is_created = False\n\n        try:\n            tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n            if tournament is None:\n                tournament = Tournament(tournament_id=tournament_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': tournament_data.get('begin_at'),\n                'detailed_stats': tournament_data.get('detailed_stats'),\n                'end_at': tournament_data.get('end_at'),\n                'has_bracket': tournament_data.get('has_bracket'),\n                'live_supported': tournament_data.get('live_supported'),\n                'modified_at': tournament_data.get('modified_at'),\n                'name': tournament_data.get('name'),\n                'prizepool': tournament_data.get('prizepool'),\n                'slug': tournament_data.get('slug'),\n                'tier': tournament_data.get('tier'),\n                'videogame': tournament_data.get('videogame'),\n                'videogame_title': tournament_data.get('videogame_title'),\n                'winner_id': tournament_data.get('winner_id'),\n                'winner_type': tournament_data.get('winner_type')\n            }\n\n            if league_data := tournament_data.get('league'):\n                league_id = league_data.get('id')\n                league = session.query(League).filter_by(league_id=league_id).one_or_none()\n                if not league:\n                    league = self.populate_leagues(session, league_data)\n                new_data['league'] = league\n\n            if serie_data := tournament_data.get('serie'):\n                serie_id = serie_data.get('id')\n                serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n                if not serie:\n                    serie = self.populate_series(session, serie_data)\n                new_data['serie'] = serie\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(tournament, key, value)\n                session.add(tournament)\n                session.commit()\n                info_logger.info(f\"New tournament {tournament_id} created.\")\n            else:\n                if self.compare_and_update(tournament, new_data):\n                    session.commit()\n                    info_logger.info(f\"Tournament {tournament_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing tournament {tournament_id} found, no updates performed.\")\n\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New tournament {tournament_id} created.\")\n            else:\n                info_logger.info(f\"Existing tournament {tournament_id} found, no updates performed.\")\n\n            return tournament\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate tournament {tournament_id}. Error: {str(error)}\")\n            for key, value in tournament_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing tournament {tournament_id}: {str(exception)}\")\n            raise\n\n    def populate_team(self, session: Session, team_data: Dict, tournament_id: Optional[int] = None) -> Optional[Team]:\n        team_id = team_data.get('id')\n        print(f\"players: {team_data}\")\n\n        is_created = False\n\n        try:\n            team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n\n            if team is None:\n                team = Team(team_id=team_id)\n                is_created = True\n\n            new_data = {\n                'acronym': team_data.get('acronym'),\n                'image_url': team_data.get('image_url'),\n                'location': team_data.get('location'),\n                'modified_at': team_data.get('modified_at'),\n                'name': team_data.get('name'),\n                'slug': team_data.get('slug')\n            }\n\n            if tournament_id:\n                tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n                if tournament:\n                    tournament.teams.append(team)\n                    info_logger.info(f\"Team {team_id} added to Tournament {tournament_id}\")\n                else:\n                    info_logger.warning(f\"Tournament ID {tournament_id} not found\")\n\n            players_data = team_data.get('players', [])\n            for player_data in players_data:\n                player_id = player_data.get('id')\n                player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n                if not player:\n                    player = self.populate_player(session, player_data)\n                if player and player not in team.players:\n                    team.players.append(player)\n                    info_logger.info(f\"Player {player_id} added to team {team_id}\")\n\n            if is_created:\n                for key, value, in new_data.items():\n                    setattr(team, key, value)\n                session.add(team)\n                session.commit()\n                info_logger.info(f\"New team created with ID {team_id}\")\n            else:\n                if self.compare_and_update(team, new_data):\n                    session.commit()\n                    info_logger.info(f\"Team {team_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing team with ID {team_id} found, no updates performed.\")\n\n            return team\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate team {team_id}. Error: {str(error)}\")\n            for key, value in team_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n        except RetryError as retry_error:\n            error_logger.error(\n                f\"RetryError occurred while fetching team stats for team ID {team_id}. Error: {retry_error}\")\n            if retry_error.last_attempt:\n                error_logger.error(f\"Last attempt exception: {retry_error.last_attempt.exception()}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing team {team_id}: {str(exception)}\")\n            raise\n\n    def populate_player(self, session: Session, player_data: Dict, team_id: Optional[int] = None) -> Optional[Player]:\n        player_id = player_data.get('id')\n        is_created = False\n\n        try:\n            player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n\n            if player is None:\n                player = Player(player_id=player_id)\n                is_created = True\n\n            new_data = {\n                'active': player_data.get('active'),\n                'age': player_data.get('age'),\n                'birthday': player_data.get('birthday'),\n                'first_name': player_data.get('first_name'),\n                'image_url': player_data.get('image_url'),\n                'last_name': player_data.get('last_name'),\n                'modified_at': player_data.get('modified_at'),\n                'name': player_data.get('name'),\n                'nationality': player_data.get('nationality'),\n                'role': player_data.get('role'),\n                'slug': player_data.get('slug')\n            }\n\n            if team_id:\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if team:\n                    if team not in player.teams:\n                        player.teams.append(team)\n                        info_logger.info(f\"Player {player_id} added to team {team_id}\")\n                else:\n                    error_logger.warning(f\"Team with ID {team_id} not found. Player not linked to any team.\")\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(player, key, value)\n                session.add(player)\n                session.commit()\n                info_logger.info(f\"New player created with ID {player_id}.\")\n            else:\n                if self.compare_and_update(player, new_data):\n                    session.commit()\n                    info_logger.info(f\"Player {player_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing player with ID {player_id} found, no updates performed.\")\n\n            return player\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate player {player_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing player {player_id}: {str(exception)}\")\n            raise\n\n    def populate_match(self, session: Session, match_data: Dict) -> Optional[Match]:\n        match_id = match_data.get('id')\n        is_created = False\n\n        try:\n            match = session.query(Match).filter_by(match_id=match_id).one_or_none()\n\n            if match is None:\n                match = Match(match_id=match_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': match_data.get('begin_at'),\n                'detailed_stats': match_data.get('detailed_stats'),\n                'draw': match_data.get('draw'),\n                'end_at': match_data.get('end_at'),\n                'forfeit': match_data.get('forfeit'),\n                'game_advantage': match_data.get('game_advantage'),\n                'live': match_data.get('live'),\n                'match_type': match_data.get('match_type'),\n                'modified_at': match_data.get('modified_at'),\n                'name': match_data.get('name'),\n                'number_of_games': match_data.get('number_of_games'),\n                'original_scheduled_at': match_data.get('original_scheduled_at'),\n                'rescheduled': match_data.get('rescheduled'),\n                'scheduled_at': match_data.get('scheduled_at'),\n                'slug': match_data.get('slug'),\n                'status': match_data.get('status'),\n                'tournament_id': match_data.get('tournament').get('id') if match_data.get('tournament') else None,\n                'winner_id': match_data.get('winner_id'),\n                'winner_type': match_data.get('winner_type')\n            }\n\n            league_data = match_data.get('league')\n            if league_data:\n                league_id = league_data.get('id')\n                league = session.query(League).filter_by(league_id=league_id).one_or_none()\n                if not league:\n                    league = self.populate_leagues(session, league_data)\n                match.league = league\n\n            serie_data = match_data.get('serie')\n            if serie_data:\n                serie_id = serie_data.get('id')\n                serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n                if not serie:\n                    serie = self.populate_series(session, serie_data)\n                match.serie = serie\n\n            tournament_data = match_data.get('tournament')\n            if tournament_data:\n                tournament_id = tournament_data.get('id')\n                tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n                if not tournament:\n                    tournament = self.populate_tournament(session, match_data)\n                match.tournament = tournament\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(match, key, value)\n                session.add(match)\n\n            session.flush()\n\n            opponents = match_data.get('opponents', [])\n            for opponent in opponents:\n                team_id = opponent.get('opponent').get('id')\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if team:\n                    if team not in match.teams:\n                        match.teams.append(team)\n                        info_logger.info(f\"Team {team_id} added to match {match_id}\")\n                else:\n                    self.populate_team(session, opponent.get('opponent'))\n                    team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                    if team:\n                        match.teams.append(team)\n                        info_logger.info(f\"Team with ID {team_id} added to database and match.\")\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(match, key, value)\n                session.add(match)\n                session.commit()\n                info_logger.info(f\"New match created with ID {match_id}.\")\n            else:\n                if self.compare_and_update(match, new_data):\n                    session.commit()\n                    info_logger.info(f\"Match {match_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing match with ID {match_id} found, no updates performed.\")\n\n            return match\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate match {match_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing match {match_id}: {str(exception)}\")\n            raise\n\n    def populate_game(self, session: Session, game_data: Dict, match_id: Optional[int] = None) -> Optional[Game]:\n        game_id = game_data.get('id')\n        is_created = False\n\n        try:\n            game = session.query(Game).filter_by(game_id=game_id).one_or_none()\n\n            if game is None:\n                game = Game(game_id=game_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': game_data.get('begin_at'),\n                'complete': game_data.get('complete'),\n                'detailed_stats': game_data.get('detailed_stats'),\n                'finished': game_data.get('finished'),\n                'forfeit': game_data.get('forfeit'),\n                'length': game_data.get('length'),\n                'status': game_data.get('status'),\n                'winner_team_id': game_data.get('winner_team_id')\n            }\n\n            if match_id:\n                match = session.query(Match).filter_by(match_id=match_id).one_or_none()\n                if match:\n                    game.match = match\n                else:\n                    error_logger.warning(f\"Match with ID {match_id} not found. Game not linked to any match.\")\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(game, key, value)\n                session.add(game)\n                session.commit()\n                info_logger.info(f\"New game created with ID {game_id}\")\n            else:\n                if self.compare_and_update(game, new_data):\n                    session.commit()\n                    info_logger.info(f\"Game {game_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing game with ID {game_id} found, no updates performed.\")\n\n            return game\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate game {game_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing game {game_id}: {str(exception)}\")\n            raise\n\n    def populate_match_result(self, session: Session, match_result_data: Dict) -> Optional[MatchResult]:\n        match_result_id = match_result_data.get('id')\n        is_created = False\n\n        try:\n            match_result = session.query(MatchResult).filter_by(id=match_result_id).one_or_none()\n\n            if match_result is None:\n                match_result = MatchResult(id=match_result_id)\n                is_created = True\n\n            match_result.match_id = match_result_data.get('match_id', match_result.match_id)\n            match_result.team1_id = match_result_data.get('team1_id', match_result.team1_id)\n            match_result.team2_id = match_result_data.get('team2_id', match_result.team2_id)\n            match_result.score_team1 = match_result_data.get('score_team1', match_result.score_team1)\n            match_result.score_team2 = match_result_data.get('score_team2', match_result.score_team2)\n\n            if is_created:\n                session.add(match_result)\n\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New match result created with ID {match_result_id}.\")\n            else:\n                info_logger.info(f\"Existing match result with ID {match_result_id} updated.\")\n            return match_result\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate match result {match_result_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing match result {match_result_id}: {str(exception)}\")\n            raise\n\n    def populate_round_score(self, session: Session, round_score_data: List[Dict[str, Any]], game_id: Optional[int]) -> None:\n        if not game_id:\n            error_logger.error(\"No game_id provided for round scores.\")\n            return\n\n        try:\n            game = session.query(Game).filter_by(game_id=game_id).one_or_none()\n            if not game:\n                error_logger.error(f\"No game found with ID {game_id}\")\n                return\n\n            print(f\"round_score_data: {round_score_data} (type: {type(round_score_data)})\")\n\n            if isinstance(round_score_data, str):\n                error_logger.error(\n                    f\"Unexpected string encountered in round_score_data for game ID {game_id}: {round_score_data}\")\n                return\n\n            for score_data in round_score_data:\n                print(f\"score_data: {score_data} (type: {type(score_data)})\")\n                if isinstance(score_data, str):\n                    error_logger.error(\n                        f\"Unexpected string encountered in score_data for game ID {game_id}: {score_data}\")\n                    continue\n\n                team_id = score_data.get('team_id')\n                if not team_id:\n                    error_logger.warning(f\"Team ID is missing in score data for game ID {game_id}: {score_data}\")\n                    continue\n\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if not team:\n                    error_logger.warning(\n                        f\"Team with ID {team_id} not found while populate round score for game ID {game_id}. Skipping score insertion.\")\n                    continue\n\n                round_score = session.query(RoundScore).filter_by(game_id=game_id, team_id=team_id).one_or_none()\n                if not round_score:\n                    round_score = RoundScore(game_id=game_id, team_id=team_id)\n                    is_created = True\n                else:\n                    is_created = False\n\n                round_score.score = score_data.get('score', round_score.score)\n\n                if is_created:\n                    session.add(round_score)\n                    info_logger.info(f\"New round score added for game {game_id} and team {team_id}.\")\n                else:\n                    info_logger.info(f\"Existing round score updated for game {game_id} and team {team_id}.\")\n\n            session.commit()\n            info_logger.info(f\"Round scores for game {game_id} have been populated.\")\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate round score for game id: {game_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing round score for game id: {game_id}: {str(exception)}\")\n            raise\n\n    def populate_player_result(self, session: Session, players_result_data: List[Dict[str, Any]], game_id: Optional[int]) -> None:\n        if not game_id:\n            error_logger.error(\"No game_id provided for player results.\")\n            return\n\n        for player_data in players_result_data:\n            player_info = player_data.get('player')\n            if not player_info:\n                continue\n\n            player_id = player_info.get('id')\n            if not player_id:\n                info_logger.warning(\"Player ID is missing in the data\")\n                continue\n\n            try:\n                player_result = session.query(PlayerResult).filter_by(player_id=player_id,\n                                                                      game_id=game_id).one_or_none()\n\n                if player_result:\n                    info_logger.info(\n                        f\"Existing player result found for player_id: {player_id} and game_id: {game_id}. Skipping \"\n                        f\"creation.\")\n                    continue\n                info_logger.info(f\"Creating new player result for player_id: {player_id} and game_id: {game_id}\")\n\n                player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n                if not player:\n                    info_logger.info(f\"Player not found. Creating new player with ID {player_id}.\")\n                    team_data = player_data.get('team')\n                    team_id = team_data.get('id') if team_data else None\n                    if team_id:\n                        team = session.query(Team).filter_by(team_id=team_data.get('id')).one_or_none()\n                        if not team:\n                            self.populate_team(session, team_data=team_data)\n                            team = session.query(Team).filter_by(team_id=team_data.get('id')).one_or_none()\n                            if not team:\n                                error_logger.warning(\n                                    f\"Team with ID {team_data.get('id')} not found even after population. Skipping \"\n                                    f\"player insertion.\")\n                                continue\n                    self.populate_player(session, player_info, team_id=team.team_id if team else None)\n\n                player_result = PlayerResult(player_id=player_id, game_id=game_id)\n                for key, value in player_data.items():\n                    if key not in ['player', 'team', 'opponent']:\n                        setattr(player_result, key, value)\n                session.add(player_result)\n                session.commit()\n                info_logger.info(f\"New player result added for player {player_id} and game {game_id}.\")\n\n            except SQLAlchemyError as error:\n                session.rollback()\n                error_logger.error(\n                    f\"Failed to populate player result for player with ID {player_id}. Error: {str(error)}\")\n                raise\n\n            except requests.exceptions.RequestException as req_error:\n                session.rollback()\n                error_logger.error(\n                    f\"HTTP request error while fetching player stats for player with ID {player_id}. Error: {str(req_error)}\")\n                raise\n\n            except KeyError as key_error:\n                session.rollback()\n                error_logger.error(\n                    f\"KeyError occurred while processing player result for player ID {player_id} and game ID {game_id}: {str(key_error)}. Player data: {player_data}\")\n                raise\n\n            except Exception as exception:\n                session.rollback()\n                error_logger.error(\n                    f\"An unexpected error occurred while processing player result for player ID {player_id}: {str(exception)}\")\n                raise\n\n    def populate_player_stats(self, session: Session, player_id: int):\n        try:\n            player_stats_data = self.make_request(url=self.get_particular_player_stats_url(player_id=player_id))\n            player_stats_data = player_stats_data.json()\n\n            # Map player_stats_data to the PlayerStats model\n            player_stats_data_mapped = {\n                'assists': player_stats_data['stats']['counts']['assists'],\n                'deaths': player_stats_data['stats']['counts']['deaths'],\n                'first_kills_diff': player_stats_data['stats']['counts']['first_kills_diff'],\n                'flash_assists': player_stats_data['stats']['counts']['flash_assists'],\n                'games_draw': player_stats_data['stats']['counts']['games_draw'],\n                'games_lost': player_stats_data['stats']['counts']['games_lost'],\n                'games_played': player_stats_data['stats']['counts']['games_played'],\n                'games_won': player_stats_data['stats']['counts']['games_won'],\n                'headshots': player_stats_data['stats']['counts']['headshots'],\n                'k_d_diff': player_stats_data['stats']['counts']['k_d_diff'],\n                'kills': player_stats_data['stats']['counts']['kills'],\n                'matches_draw': player_stats_data['stats']['counts']['matches_draw'],\n                'matches_lost': player_stats_data['stats']['counts']['matches_lost'],\n                'matches_played': player_stats_data['stats']['counts']['matches_played'],\n                'matches_won': player_stats_data['stats']['counts']['matches_won'],\n                'rounds_played': player_stats_data['stats']['counts']['rounds_played'],\n                'adr_per_game': player_stats_data['stats']['per_game_averages']['adr'],\n                'assists_per_game': player_stats_data['stats']['per_game_averages']['assists'],\n                'deaths_per_game': player_stats_data['stats']['per_game_averages']['deaths'],\n                'first_kills_diff_per_game': player_stats_data['stats']['per_game_averages']['first_kills_diff'],\n                'flash_assists_per_game': player_stats_data['stats']['per_game_averages']['flash_assists'],\n                'headshots_per_game': player_stats_data['stats']['per_game_averages']['headshots'],\n                'hltv_game_rating': player_stats_data['stats']['per_game_averages']['hltv_game_rating'],\n                'k_d_diff_per_game': player_stats_data['stats']['per_game_averages']['k_d_diff'],\n                'kast_per_game': player_stats_data['stats']['per_game_averages']['kast'],\n                'kills_per_game': player_stats_data['stats']['per_game_averages']['kills'],\n                'assists_per_round': player_stats_data['stats']['per_round_averages']['assists'],\n                'deaths_per_round': player_stats_data['stats']['per_round_averages']['deaths'],\n                'first_kills_diff_per_round': player_stats_data['stats']['per_round_averages']['first_kills_diff'],\n                'flash_assists_per_round': player_stats_data['stats']['per_round_averages']['flash_assists'],\n                'headshots_per_round': player_stats_data['stats']['per_round_averages']['headshots'],\n                'k_d_diff_per_round': player_stats_data['stats']['per_round_averages']['k_d_diff'],\n                'kills_per_round': player_stats_data['stats']['per_round_averages']['kills'],\n            }\n\n            # Fetch the existing player stats from the database\n            existing_player_stats = session.query(PlayerStats).filter_by(player_id=player_id).one_or_none()\n\n            # Check if player stats need to be updated\n            if existing_player_stats:\n                if self.compare_and_update(existing_player_stats, player_stats_data_mapped):\n                    info_logger.info(f\"Player stats updated for player {player_id}.\")\n            else:\n                player_stats = PlayerStats(player_id=player_id, **player_stats_data_mapped)\n                session.add(player_stats)\n                info_logger.info(f\"New player stats added for player {player_id}.\")\n\n            # Commit the changes to the database\n            session.commit()\n\n        except requests.exceptions.RequestException as req_error:\n            error_logger.error(\n                f\"HTTP request error while fetching player stats for player ID {player_id}. Error: {str(req_error)}\")\n\n        except SQLAlchemyError as db_error:\n            session.rollback()\n            error_logger.error(\n                f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n\n        except KeyError as key_error:\n            error_logger.error(\n                f\"KeyError occurred while processing player stats for player ID {player_id}: {str(key_error)}. \"\n                f\"Response: {player_stats_data}\")\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing player stats for player ID {player_id}: {str(exception)}\")\n\n    def populate_stream(self, session: Session, stream_data: Dict[str, Any]) -> Optional[Stream]:\n        stream_id: int = stream_data.get('id')\n        is_created = False\n\n        try:\n            stream = session.query(Stream).filter_by(id=stream_id).one_or_none()\n\n            if stream is None:\n                stream = Stream(id=stream_id)\n                is_created = True\n\n            stream_data_mapped = {\n                'embed_url': stream_data.get('embed_url'),\n                'language': stream_data.get('language'),\n                'main': stream_data.get('main'),\n                'official': stream_data.get('official'),\n                'raw_url': stream_data.get('raw_url'),\n                'match_id': stream_data.get('match_id')\n            }\n\n            if is_created:\n                for key, value in stream_data_mapped.items():\n                    setattr(stream, key, value)\n                session.add(stream)\n            else:\n                if self.compare_and_update(stream, stream_data_mapped):\n                    info_logger.info(f\"Stream updated with ID {stream_id}\")\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New stream created with ID {stream_id}.\")\n            else:\n                info_logger.info(f\"Existing stream with ID {stream_id} updated.\")\n\n            return stream\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate stream {stream_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing stream {stream_id}: {str(exception)}\")\n            raise\n\n    def main_population(self, fetched_data: List[Dict[str, Any]]) -> None:\n        with self.database_manager.get_session() as session:\n            teams_ids = set()\n            processed_tournaments = set()\n            processed_matches = set()\n            processed_teams = set()\n            processed_players = set()\n            processed_games = set()\n            match_counter = 0\n\n            for match in fetched_data:\n\n                match_id = match.get('id')\n                if match_id in processed_matches:\n                    info_logger.info(f\"Skipping already processed match with ID {match_id}\")\n                    continue\n\n                try:\n                    # tournament populates league and series info altogether\n                    tournament_data = match.get('tournament')\n                    tournament_id = tournament_data.get('id')\n                    if tournament_id not in processed_tournaments:\n                        # Match is passed as a parameter because league and series is populates altogether\n                        self.populate_tournament(session, match)\n                        processed_tournaments.add(tournament_id)\n                    self.populate_match(session, match)\n                    processed_matches.add(match_id)\n\n                    teams_pair = match.get('opponents')\n                    for team in teams_pair:\n                        try:\n                            team_id = team.get('opponent').get('id')\n                            if team_id in processed_teams:\n                                info_logger.info(f\"Skipping already processed team with ID {team_id}\")\n                                continue\n\n                            self.populate_team(session, team.get('opponent'), tournament_id=tournament_id)\n                            teams_ids.add(team_id)\n                            teams_response = self.make_request(url=self.get_particular_team_url(team_id=team_id)).json()\n                            processed_teams.add(team_id)\n\n                            for player in teams_response.get('players'):\n                                player_id = player.get('id')\n                                if player_id in processed_players:\n                                    info_logger.info(f\"Skipping already processed player with ID {player_id}\")\n                                    continue\n                                try:\n\n                                    self.populate_player(session, player, team_id=team_id)\n                                    processed_players.add(player_id)\n                                    last_70_games = self.fetch_last_games(player_id=player_id)\n                                    for game_id in last_70_games:\n                                        if game_id in processed_games:\n                                            info_logger.info(f\"Skipping already processed game with ID {game_id}\")\n                                            continue\n                                        try:\n                                            game_response = self.make_request(\n                                                url=self.get_particular_game_stats_url(game_id)).json()\n                                            match_data = game_response.get('match') or \"Match_data has some issues\"\n                                            rounds_scores_data = game_response.get(\n                                                'rounds_score') or \"Round scores data missing\"\n                                            players_results_data = game_response.get(\n                                                'players') or \"Players results data missing\"\n\n                                            new_tournament_data = match_data.get(\n                                                'tournament') if match_data != \"Match_data has some issues\" else \"Tournament data missing\"\n                                            new_tournament_id = new_tournament_data.get(\n                                                'id') if new_tournament_data else None\n                                            if new_tournament_id and new_tournament_id not in processed_tournaments:\n                                                self.populate_tournament(session, match_data)\n                                                processed_tournaments.add(new_tournament_id)\n                                            new_match_id = match_data.get('id') or \"new_match_id is None\"\n                                            if new_match_id and new_match_id not in processed_matches:\n                                                self.populate_match(session, match_data)\n                                                processed_matches.add(new_match_id)\n\n                                            self.populate_game(session, game_response,\n                                                               match_id=game_response.get('match_id', None))\n                                            self.populate_round_score(session, round_score_data=rounds_scores_data,\n                                                                      game_id=game_response.get('id', None))\n                                            self.populate_player_result(session, players_results_data,\n                                                                        game_id=game_response.get('id'))\n                                            processed_games.add(game_id)\n                                            info_logger.info(f\"Finished processing game with ID {game_id}\")\n\n                                        except requests.exceptions.RequestException as req_error:\n                                            error_logger.error(\n                                                f\"HTTP request error while fetching game stats for game ID {game_id}. Error: {str(req_error)}\")\n                                        except psycopg2_errors.NotNullViolation as db_error:\n                                            error_logger.error(\n                                                f\"Database error while processing game stats for game ID {game_id}: {str(db_error)}\")\n                                        except KeyError as key_error:\n                                            error_logger.error(\n                                                f\"KeyError occurred while processing game stats for game ID {game_id}: {str(key_error)}. Response: {game_response}\")\n                                        except Exception as exception:\n                                            error_logger.error(\n                                                f\"An unexpected error occurred while processing game stats for game ID {game_id}: {str(exception)}\")\n\n                                except requests.exceptions.RequestException as req_error:\n                                    error_logger.error(\n                                        f\"HTTP request error while fetching player stats for player ID {player_id}. Error: {str(req_error)}\")\n                                except psycopg2_errors.NotNullViolation as db_error:\n                                    error_logger.error(\n                                        f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                                except KeyError as key_error:\n                                    error_logger.error(\n                                        f\"KeyError occurred while processing player stats for player ID {player_id}: {str(key_error)}. Response: {player}\")\n                                except Exception as exception:\n                                    error_logger.error(\n                                        f\"An unexpected error occurred while processing player stats for player ID {player_id}: {str(exception)}\")\n\n                                self.populate_player_stats(session, player_id=player_id)\n\n                        except requests.exceptions.RequestException as req_error:\n                            error_logger.error(\n                                f\"HTTP request error while fetching team stats for team ID {team_id}. Error: {str(req_error)}\")\n                        except psycopg2_errors.NotNullViolation as db_error:\n                            error_logger.error(\n                                f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                        except KeyError as key_error:\n                            error_logger.error(\n                                f\"KeyError occurred while processing team stats for team ID {team_id}: {str(key_error)}. Response: {team}\")\n                        except RetryError as retry_error:\n                            error_logger.error(\n                                f\"RetryError occurred while fetching team stats for team ID {team_id}. Error: {retry_error}\")\n                            if retry_error.last_attempt:\n                                error_logger.error(f\"Last attempt exception: {retry_error.last_attempt.exception()}\")\n                            raise\n                        except Exception as exception:\n                            error_logger.error(\n                                f\"An unexpected error occurred while processing team stats for team ID {team_id}: {str(exception)}\")\n\n                    match_counter += 1\n                    info_logger.info(f\"Processed until now {match_counter} matches.\")\n                except requests.exceptions.RequestException as req_error:\n                    error_logger.error(\n                        f\"HTTP request error while fetching match stats for match ID {match_id}. Error: {str(req_error)}\")\n                except psycopg2_errors.NotNullViolation as db_error:\n                    error_logger.error(\n                        f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                except KeyError as key_error:\n                    error_logger.error(\n                        f\"KeyError occurred while processing match stats for match ID {match_id}: {str(key_error)}. Response: {match}\")\n                except Exception as exception:\n                    error_logger.error(\n                        f\"An unexpected error occurred while processing match stats for match ID {match_id}: {str(exception)}\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.__init__",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, api_token: str, user: str, password: str, host: str, port: str, db_name: str",
    "docstring": null,
    "description": null,
    "first_lines": "        self.headers = {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_token}\"\n        }\n        self.database_manager = DatabaseManager(user=user, password=password, host=host, port=port, db_name=db_name)",
    "lineno": 32,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def __init__(self, api_token: str, user: str, password: str, host: str, port: str, db_name: str) -> None:\n        self.headers = {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_token}\"\n        }\n        self.database_manager = DatabaseManager(user=user, password=password, host=host, port=port, db_name=db_name)",
    "documented_params": [],
    "actual_params": [
      "api_token",
      "user",
      "password",
      "host",
      "port",
      "db_name"
    ],
    "missing_params": [
      "api_token",
      "user",
      "password",
      "host",
      "port",
      "db_name"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "api_token": "str",
      "user": "str",
      "password": "str",
      "host": "str",
      "port": "str",
      "db_name": "str"
    },
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['api_token', 'user', 'password', 'host', 'port', 'db_name']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 70.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.make_request",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, url: str, params: Optional[Dict]=None",
    "docstring": null,
    "description": null,
    "first_lines": "        response = requests.get(url=url, headers=self.headers, params=params, timeout=10)\n        time.sleep(0.4)\n        PlayerUpdater.REQUEST_COUNTER += 1\n        response.raise_for_status()\n        info_logger.info(f\"Total requests made to Pandascore API: {PlayerUpdater.REQUEST_COUNTER}. I've hit url: {url}\")",
    "lineno": 40,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def make_request(self, url: str, params: Optional[Dict] = None) -> requests.Response:\n        response = requests.get(url=url, headers=self.headers, params=params, timeout=10)\n        time.sleep(0.4)\n        PlayerUpdater.REQUEST_COUNTER += 1\n        response.raise_for_status()\n        info_logger.info(f\"Total requests made to Pandascore API: {PlayerUpdater.REQUEST_COUNTER}. I've hit url: {url}\")\n        return response",
    "documented_params": [],
    "actual_params": [
      "url",
      "params"
    ],
    "missing_params": [
      "url",
      "params"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "url": "str",
      "params": "Optional[Dict]"
    },
    "return_type": "requests.Response",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['url', 'params']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.get_upcoming_matches",
    "path": "",
    "method": "FUNCTION",
    "signature": "self",
    "docstring": null,
    "description": null,
    "first_lines": "        params = {\n            \"filter[future]\": \"true\",\n            \"sort\": \"begin_at\",\n            \"per_page\": 100,\n            \"page\": 1",
    "lineno": 48,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def get_upcoming_matches(self) -> List[Dict]:\n        params = {\n            \"filter[future]\": \"true\",\n            \"sort\": \"begin_at\",\n            \"per_page\": 100,\n            \"page\": 1\n        }\n        all_upcoming_matches: List[Dict] = []\n        while True:\n            try:\n                response = self.make_request(self.UPCOMING_MATCHES_URL, params=params)\n                matches = response.json()\n                if not matches:\n                    break\n                all_upcoming_matches.extend(matches)\n                info_logger.info(f\"Fetched {len(matches)} matches on page {params['page']}\")\n                params['page'] += 1\n            except requests.exceptions.RequestException as req_exception:\n                error_logger.error(f\"Error fetching upcoming matches on page {params['page']}: {req_exception}\")\n        info_logger.info(f\"Total matches fetched: {len(all_upcoming_matches)}\")\n        return all_upcoming_matches",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "List[Dict]",
    "has_type_hints": true,
    "coverage_score": 50.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 80.0,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.get_particular_team_url",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, team_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "        return f'https://api.pandascore.co/teams/{team_id}'",
    "lineno": 70,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def get_particular_team_url(self, team_id: int) -> str:\n        return f'https://api.pandascore.co/teams/{team_id}'",
    "documented_params": [],
    "actual_params": [
      "team_id"
    ],
    "missing_params": [
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "int"
    },
    "return_type": "str",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.get_particular_player_stats_url",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, player_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "        return f\"https://api.pandascore.co/csgo/players/{player_id}/stats\"",
    "lineno": 73,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def get_particular_player_stats_url(self, player_id: int) -> str:\n        return f\"https://api.pandascore.co/csgo/players/{player_id}/stats\"",
    "documented_params": [],
    "actual_params": [
      "player_id"
    ],
    "missing_params": [
      "player_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "player_id": "int"
    },
    "return_type": "str",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['player_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.get_particular_game_stats_url",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, game_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "        return f'https://api.pandascore.co/csgo/games/{game_id}'",
    "lineno": 76,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def get_particular_game_stats_url(self, game_id: int) -> str:\n        return f'https://api.pandascore.co/csgo/games/{game_id}'",
    "documented_params": [],
    "actual_params": [
      "game_id"
    ],
    "missing_params": [
      "game_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "game_id": "int"
    },
    "return_type": "str",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['game_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.get_required_matches_for_particular_player",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, player_id: int, required_amount_of_matches: int",
    "docstring": null,
    "description": null,
    "first_lines": "        return f\"https://api.pandascore.co/players/{player_id}/matches?per_page{required_amount_of_matches}&sort=-modified_at\"",
    "lineno": 79,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def get_required_matches_for_particular_player(self, player_id: int, required_amount_of_matches: int) -> str:\n        return f\"https://api.pandascore.co/players/{player_id}/matches?per_page{required_amount_of_matches}&sort=-modified_at\"",
    "documented_params": [],
    "actual_params": [
      "player_id",
      "required_amount_of_matches"
    ],
    "missing_params": [
      "player_id",
      "required_amount_of_matches"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "player_id": "int",
      "required_amount_of_matches": "int"
    },
    "return_type": "str",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['player_id', 'required_amount_of_matches']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.compare_and_update",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, existing_data: object, new_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "        updated = False\n        for key, value in new_data.items():\n            if getattr(existing_data, key) != value:\n                setattr(existing_data, key, value)\n                updated = True",
    "lineno": 82,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def compare_and_update(self, existing_data: object, new_data: Dict) -> bool:\n        updated = False\n        for key, value in new_data.items():\n            if getattr(existing_data, key) != value:\n                setattr(existing_data, key, value)\n                updated = True\n        return updated",
    "documented_params": [],
    "actual_params": [
      "existing_data",
      "new_data"
    ],
    "missing_params": [
      "existing_data",
      "new_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "existing_data": "object",
      "new_data": "Dict"
    },
    "return_type": "bool",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['existing_data', 'new_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.fetch_last_games",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, player_id: int, total_games: int=70",
    "docstring": null,
    "description": null,
    "first_lines": "        games_collected: List[int] = []\n        page = 1\n\n        while len(games_collected) < total_games:\n            matches_url = self.get_required_matches_for_particular_player(player_id,",
    "lineno": 90,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def fetch_last_games(self, player_id: int, total_games: int = 70) -> List[int]:\n        games_collected: List[int] = []\n        page = 1\n\n        while len(games_collected) < total_games:\n            matches_url = self.get_required_matches_for_particular_player(player_id,\n                                                                          required_amount_of_matches=total_games)\n            try:\n                response = self.make_request(url=matches_url)\n                matches = response.json()\n                if not matches:\n                    error_logger.error(f\"No matches found for player {player_id} on page {page}\")\n                    break\n\n                for match in matches:\n                    games = match.get('games', [])\n                    if games is None:\n                        error_logger.error(f\"No games data found in match for player {player_id}. Match data: {match}\")\n                        continue\n                    for game in games:\n                        game_id = game.get('id')\n                        if game_id:\n                            games_collected.append(game_id)\n                            if len(games_collected) >= total_games:\n                                break\n                    if len(games_collected) >= total_games:\n                        break\n\n                if len(games_collected) >= total_games:\n                    break\n\n            except requests.exceptions.RequestException as req_exception:\n                error_logger.error(\n                    f\"RequestException occurred while fetching data for player {player_id}: {req_exception}\")\n                break\n            except ValueError as val_err:\n                error_logger.error(\n                    f\"ValueError occurred while processing JSON response for player {player_id}: {val_err}\")\n                break\n            except KeyError as key_err:\n                error_logger.error(\n                    f\"KeyError occurred while fetching games for player {player_id}: {key_err}. Response: {response.text}\")\n                break\n            except Exception as e:\n                error_logger.error(f\"An unexpected error occurred while fetching games for player {player_id}: {e}\")\n                break\n\n            page += 1\n\n        print(f\"games_collected: {len(games_collected)}\")\n        return games_collected[:total_games]",
    "documented_params": [],
    "actual_params": [
      "player_id",
      "total_games"
    ],
    "missing_params": [
      "player_id",
      "total_games"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "player_id": "int",
      "total_games": "int"
    },
    "return_type": "List[int]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['player_id', 'total_games']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_leagues",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, league_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "\n        league_id: int = league_data.get('id')\n        is_created = False\n\n        try:",
    "lineno": 142,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_leagues(self, session: Session, league_data: Dict) -> Optional[League]:\n\n        league_id: int = league_data.get('id')\n        is_created = False\n\n        try:\n            league = session.query(League).filter_by(league_id=league_id).one_or_none()\n\n            if league is None:\n                league = League(league_id=league_id)\n                is_created = True\n\n            new_data = {\n                'image_url': league_data.get('image_url'),\n                'modified_at': league_data.get('modified_at'),\n                'name': league_data.get('name'),\n                'slug': league_data.get('slug'),\n                'url': league_data.get('url')\n            }\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(league, key, value)\n                session.add(league)\n                session.commit()\n                info_logger.info(f\"New league {league_id} created.\")\n            else:\n                if self.compare_and_update(league, new_data):\n                    session.commit()\n                    info_logger.info(f\"League {league_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing league {league_id}, no updates performed.\")\n\n            return league\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate league {league_id}. Error: {str(error)}\")\n            for key, value in league_data.items():\n                error_logger.error(f\"{key}: {value}\")\n\n            raise\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing league {league_id}. Error: {str(exception)}\")",
    "documented_params": [],
    "actual_params": [
      "session",
      "league_data"
    ],
    "missing_params": [
      "session",
      "league_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "league_data": "Dict"
    },
    "return_type": "Optional[League]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'league_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_series",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, series_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "        serie_id: int = series_data.get('id')\n        is_created = False\n\n        try:\n            serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()",
    "lineno": 189,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_series(self, session: Session, series_data: Dict) -> Optional[Serie]:\n        serie_id: int = series_data.get('id')\n        is_created = False\n\n        try:\n            serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n\n            if serie is None:\n                serie = Serie(serie_id=serie_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': series_data.get('begin_at'),\n                'end_at': series_data.get('end_at'),\n                'full_name': series_data.get('full_name'),\n                'league_id': series_data.get('league_id'),\n                'modified_at': series_data.get('modified_at'),\n                'name': series_data.get('name'),\n                'season': series_data.get('season'),\n                'slug': series_data.get('slug'),\n                'winner_id': series_data.get('winner_id'),\n                'winner_type': series_data.get('winner_type'),\n                'year': series_data.get('year')\n            }\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(serie, key, value)\n                session.add(serie)\n                session.commit()\n                info_logger.info(f\"New series {serie_id} created.\")\n            else:\n                if self.compare_and_update(serie, new_data):\n                    session.commit()\n                    info_logger.info(f\"Series {serie_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing series {serie_id} found, no updates performed.\")\n\n            return serie\n\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate series {serie_id}. Error: {str(error)}\")\n            for key, value in series_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing series {serie_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "series_data"
    ],
    "missing_params": [
      "session",
      "series_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "series_data": "Dict"
    },
    "return_type": "Optional[Serie]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'series_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_tournament",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, match_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "        tournament_id: int = match_data.get('tournament').get('id')\n        tournament_data = match_data.get('tournament')\n        is_created = False\n\n        try:",
    "lineno": 242,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_tournament(self, session: Session, match_data: Dict) -> Optional[Tournament]:\n        tournament_id: int = match_data.get('tournament').get('id')\n        tournament_data = match_data.get('tournament')\n        is_created = False\n\n        try:\n            tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n            if tournament is None:\n                tournament = Tournament(tournament_id=tournament_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': tournament_data.get('begin_at'),\n                'detailed_stats': tournament_data.get('detailed_stats'),\n                'end_at': tournament_data.get('end_at'),\n                'has_bracket': tournament_data.get('has_bracket'),\n                'live_supported': tournament_data.get('live_supported'),\n                'modified_at': tournament_data.get('modified_at'),\n                'name': tournament_data.get('name'),\n                'prizepool': tournament_data.get('prizepool'),\n                'slug': tournament_data.get('slug'),\n                'tier': tournament_data.get('tier'),\n                'videogame': tournament_data.get('videogame'),\n                'videogame_title': tournament_data.get('videogame_title'),\n                'winner_id': tournament_data.get('winner_id'),\n                'winner_type': tournament_data.get('winner_type')\n            }\n\n            if league_data := tournament_data.get('league'):\n                league_id = league_data.get('id')\n                league = session.query(League).filter_by(league_id=league_id).one_or_none()\n                if not league:\n                    league = self.populate_leagues(session, league_data)\n                new_data['league'] = league\n\n            if serie_data := tournament_data.get('serie'):\n                serie_id = serie_data.get('id')\n                serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n                if not serie:\n                    serie = self.populate_series(session, serie_data)\n                new_data['serie'] = serie\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(tournament, key, value)\n                session.add(tournament)\n                session.commit()\n                info_logger.info(f\"New tournament {tournament_id} created.\")\n            else:\n                if self.compare_and_update(tournament, new_data):\n                    session.commit()\n                    info_logger.info(f\"Tournament {tournament_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing tournament {tournament_id} found, no updates performed.\")\n\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New tournament {tournament_id} created.\")\n            else:\n                info_logger.info(f\"Existing tournament {tournament_id} found, no updates performed.\")\n\n            return tournament\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate tournament {tournament_id}. Error: {str(error)}\")\n            for key, value in tournament_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing tournament {tournament_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "match_data"
    ],
    "missing_params": [
      "session",
      "match_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "match_data": "Dict"
    },
    "return_type": "Optional[Tournament]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'match_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_team",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, team_data: Dict, tournament_id: Optional[int]=None",
    "docstring": null,
    "description": null,
    "first_lines": "        team_id = team_data.get('id')\n        print(f\"players: {team_data}\")\n\n        is_created = False\n",
    "lineno": 319,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_team(self, session: Session, team_data: Dict, tournament_id: Optional[int] = None) -> Optional[Team]:\n        team_id = team_data.get('id')\n        print(f\"players: {team_data}\")\n\n        is_created = False\n\n        try:\n            team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n\n            if team is None:\n                team = Team(team_id=team_id)\n                is_created = True\n\n            new_data = {\n                'acronym': team_data.get('acronym'),\n                'image_url': team_data.get('image_url'),\n                'location': team_data.get('location'),\n                'modified_at': team_data.get('modified_at'),\n                'name': team_data.get('name'),\n                'slug': team_data.get('slug')\n            }\n\n            if tournament_id:\n                tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n                if tournament:\n                    tournament.teams.append(team)\n                    info_logger.info(f\"Team {team_id} added to Tournament {tournament_id}\")\n                else:\n                    info_logger.warning(f\"Tournament ID {tournament_id} not found\")\n\n            players_data = team_data.get('players', [])\n            for player_data in players_data:\n                player_id = player_data.get('id')\n                player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n                if not player:\n                    player = self.populate_player(session, player_data)\n                if player and player not in team.players:\n                    team.players.append(player)\n                    info_logger.info(f\"Player {player_id} added to team {team_id}\")\n\n            if is_created:\n                for key, value, in new_data.items():\n                    setattr(team, key, value)\n                session.add(team)\n                session.commit()\n                info_logger.info(f\"New team created with ID {team_id}\")\n            else:\n                if self.compare_and_update(team, new_data):\n                    session.commit()\n                    info_logger.info(f\"Team {team_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing team with ID {team_id} found, no updates performed.\")\n\n            return team\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate team {team_id}. Error: {str(error)}\")\n            for key, value in team_data.items():\n                error_logger.debug(f\"{key}: {value}\")\n            raise\n        except RetryError as retry_error:\n            error_logger.error(\n                f\"RetryError occurred while fetching team stats for team ID {team_id}. Error: {retry_error}\")\n            if retry_error.last_attempt:\n                error_logger.error(f\"Last attempt exception: {retry_error.last_attempt.exception()}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing team {team_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "team_data",
      "tournament_id"
    ],
    "missing_params": [
      "session",
      "team_data",
      "tournament_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "team_data": "Dict",
      "tournament_id": "Optional[int]"
    },
    "return_type": "Optional[Team]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'team_data', 'tournament_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_player",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, player_data: Dict, team_id: Optional[int]=None",
    "docstring": null,
    "description": null,
    "first_lines": "        player_id = player_data.get('id')\n        is_created = False\n\n        try:\n            player = session.query(Player).filter_by(player_id=player_id).one_or_none()",
    "lineno": 392,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_player(self, session: Session, player_data: Dict, team_id: Optional[int] = None) -> Optional[Player]:\n        player_id = player_data.get('id')\n        is_created = False\n\n        try:\n            player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n\n            if player is None:\n                player = Player(player_id=player_id)\n                is_created = True\n\n            new_data = {\n                'active': player_data.get('active'),\n                'age': player_data.get('age'),\n                'birthday': player_data.get('birthday'),\n                'first_name': player_data.get('first_name'),\n                'image_url': player_data.get('image_url'),\n                'last_name': player_data.get('last_name'),\n                'modified_at': player_data.get('modified_at'),\n                'name': player_data.get('name'),\n                'nationality': player_data.get('nationality'),\n                'role': player_data.get('role'),\n                'slug': player_data.get('slug')\n            }\n\n            if team_id:\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if team:\n                    if team not in player.teams:\n                        player.teams.append(team)\n                        info_logger.info(f\"Player {player_id} added to team {team_id}\")\n                else:\n                    error_logger.warning(f\"Team with ID {team_id} not found. Player not linked to any team.\")\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(player, key, value)\n                session.add(player)\n                session.commit()\n                info_logger.info(f\"New player created with ID {player_id}.\")\n            else:\n                if self.compare_and_update(player, new_data):\n                    session.commit()\n                    info_logger.info(f\"Player {player_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing player with ID {player_id} found, no updates performed.\")\n\n            return player\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate player {player_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing player {player_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "player_data",
      "team_id"
    ],
    "missing_params": [
      "session",
      "player_data",
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "player_data": "Dict",
      "team_id": "Optional[int]"
    },
    "return_type": "Optional[Player]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'player_data', 'team_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_match",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, match_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "        match_id = match_data.get('id')\n        is_created = False\n\n        try:\n            match = session.query(Match).filter_by(match_id=match_id).one_or_none()",
    "lineno": 450,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_match(self, session: Session, match_data: Dict) -> Optional[Match]:\n        match_id = match_data.get('id')\n        is_created = False\n\n        try:\n            match = session.query(Match).filter_by(match_id=match_id).one_or_none()\n\n            if match is None:\n                match = Match(match_id=match_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': match_data.get('begin_at'),\n                'detailed_stats': match_data.get('detailed_stats'),\n                'draw': match_data.get('draw'),\n                'end_at': match_data.get('end_at'),\n                'forfeit': match_data.get('forfeit'),\n                'game_advantage': match_data.get('game_advantage'),\n                'live': match_data.get('live'),\n                'match_type': match_data.get('match_type'),\n                'modified_at': match_data.get('modified_at'),\n                'name': match_data.get('name'),\n                'number_of_games': match_data.get('number_of_games'),\n                'original_scheduled_at': match_data.get('original_scheduled_at'),\n                'rescheduled': match_data.get('rescheduled'),\n                'scheduled_at': match_data.get('scheduled_at'),\n                'slug': match_data.get('slug'),\n                'status': match_data.get('status'),\n                'tournament_id': match_data.get('tournament').get('id') if match_data.get('tournament') else None,\n                'winner_id': match_data.get('winner_id'),\n                'winner_type': match_data.get('winner_type')\n            }\n\n            league_data = match_data.get('league')\n            if league_data:\n                league_id = league_data.get('id')\n                league = session.query(League).filter_by(league_id=league_id).one_or_none()\n                if not league:\n                    league = self.populate_leagues(session, league_data)\n                match.league = league\n\n            serie_data = match_data.get('serie')\n            if serie_data:\n                serie_id = serie_data.get('id')\n                serie = session.query(Serie).filter_by(serie_id=serie_id).one_or_none()\n                if not serie:\n                    serie = self.populate_series(session, serie_data)\n                match.serie = serie\n\n            tournament_data = match_data.get('tournament')\n            if tournament_data:\n                tournament_id = tournament_data.get('id')\n                tournament = session.query(Tournament).filter_by(tournament_id=tournament_id).one_or_none()\n                if not tournament:\n                    tournament = self.populate_tournament(session, match_data)\n                match.tournament = tournament\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(match, key, value)\n                session.add(match)\n\n            session.flush()\n\n            opponents = match_data.get('opponents', [])\n            for opponent in opponents:\n                team_id = opponent.get('opponent').get('id')\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if team:\n                    if team not in match.teams:\n                        match.teams.append(team)\n                        info_logger.info(f\"Team {team_id} added to match {match_id}\")\n                else:\n                    self.populate_team(session, opponent.get('opponent'))\n                    team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                    if team:\n                        match.teams.append(team)\n                        info_logger.info(f\"Team with ID {team_id} added to database and match.\")\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(match, key, value)\n                session.add(match)\n                session.commit()\n                info_logger.info(f\"New match created with ID {match_id}.\")\n            else:\n                if self.compare_and_update(match, new_data):\n                    session.commit()\n                    info_logger.info(f\"Match {match_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing match with ID {match_id} found, no updates performed.\")\n\n            return match\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate match {match_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing match {match_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "match_data"
    ],
    "missing_params": [
      "session",
      "match_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "match_data": "Dict"
    },
    "return_type": "Optional[Match]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'match_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_game",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, game_data: Dict, match_id: Optional[int]=None",
    "docstring": null,
    "description": null,
    "first_lines": "        game_id = game_data.get('id')\n        is_created = False\n\n        try:\n            game = session.query(Game).filter_by(game_id=game_id).one_or_none()",
    "lineno": 554,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_game(self, session: Session, game_data: Dict, match_id: Optional[int] = None) -> Optional[Game]:\n        game_id = game_data.get('id')\n        is_created = False\n\n        try:\n            game = session.query(Game).filter_by(game_id=game_id).one_or_none()\n\n            if game is None:\n                game = Game(game_id=game_id)\n                is_created = True\n\n            new_data = {\n                'begin_at': game_data.get('begin_at'),\n                'complete': game_data.get('complete'),\n                'detailed_stats': game_data.get('detailed_stats'),\n                'finished': game_data.get('finished'),\n                'forfeit': game_data.get('forfeit'),\n                'length': game_data.get('length'),\n                'status': game_data.get('status'),\n                'winner_team_id': game_data.get('winner_team_id')\n            }\n\n            if match_id:\n                match = session.query(Match).filter_by(match_id=match_id).one_or_none()\n                if match:\n                    game.match = match\n                else:\n                    error_logger.warning(f\"Match with ID {match_id} not found. Game not linked to any match.\")\n\n            if is_created:\n                for key, value in new_data.items():\n                    setattr(game, key, value)\n                session.add(game)\n                session.commit()\n                info_logger.info(f\"New game created with ID {game_id}\")\n            else:\n                if self.compare_and_update(game, new_data):\n                    session.commit()\n                    info_logger.info(f\"Game {game_id} updated.\")\n                else:\n                    info_logger.info(f\"Existing game with ID {game_id} found, no updates performed.\")\n\n            return game\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate game {game_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing game {game_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "game_data",
      "match_id"
    ],
    "missing_params": [
      "session",
      "game_data",
      "match_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "game_data": "Dict",
      "match_id": "Optional[int]"
    },
    "return_type": "Optional[Game]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'game_data', 'match_id']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_match_result",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, match_result_data: Dict",
    "docstring": null,
    "description": null,
    "first_lines": "        match_result_id = match_result_data.get('id')\n        is_created = False\n\n        try:\n            match_result = session.query(MatchResult).filter_by(id=match_result_id).one_or_none()",
    "lineno": 608,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_match_result(self, session: Session, match_result_data: Dict) -> Optional[MatchResult]:\n        match_result_id = match_result_data.get('id')\n        is_created = False\n\n        try:\n            match_result = session.query(MatchResult).filter_by(id=match_result_id).one_or_none()\n\n            if match_result is None:\n                match_result = MatchResult(id=match_result_id)\n                is_created = True\n\n            match_result.match_id = match_result_data.get('match_id', match_result.match_id)\n            match_result.team1_id = match_result_data.get('team1_id', match_result.team1_id)\n            match_result.team2_id = match_result_data.get('team2_id', match_result.team2_id)\n            match_result.score_team1 = match_result_data.get('score_team1', match_result.score_team1)\n            match_result.score_team2 = match_result_data.get('score_team2', match_result.score_team2)\n\n            if is_created:\n                session.add(match_result)\n\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New match result created with ID {match_result_id}.\")\n            else:\n                info_logger.info(f\"Existing match result with ID {match_result_id} updated.\")\n            return match_result\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate match result {match_result_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing match result {match_result_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "match_result_data"
    ],
    "missing_params": [
      "session",
      "match_result_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "match_result_data": "Dict"
    },
    "return_type": "Optional[MatchResult]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'match_result_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_round_score",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, round_score_data: List[Dict[str, Any]], game_id: Optional[int]",
    "docstring": null,
    "description": null,
    "first_lines": "        if not game_id:\n            error_logger.error(\"No game_id provided for round scores.\")\n            return\n\n        try:",
    "lineno": 647,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_round_score(self, session: Session, round_score_data: List[Dict[str, Any]], game_id: Optional[int]) -> None:\n        if not game_id:\n            error_logger.error(\"No game_id provided for round scores.\")\n            return\n\n        try:\n            game = session.query(Game).filter_by(game_id=game_id).one_or_none()\n            if not game:\n                error_logger.error(f\"No game found with ID {game_id}\")\n                return\n\n            print(f\"round_score_data: {round_score_data} (type: {type(round_score_data)})\")\n\n            if isinstance(round_score_data, str):\n                error_logger.error(\n                    f\"Unexpected string encountered in round_score_data for game ID {game_id}: {round_score_data}\")\n                return\n\n            for score_data in round_score_data:\n                print(f\"score_data: {score_data} (type: {type(score_data)})\")\n                if isinstance(score_data, str):\n                    error_logger.error(\n                        f\"Unexpected string encountered in score_data for game ID {game_id}: {score_data}\")\n                    continue\n\n                team_id = score_data.get('team_id')\n                if not team_id:\n                    error_logger.warning(f\"Team ID is missing in score data for game ID {game_id}: {score_data}\")\n                    continue\n\n                team = session.query(Team).filter_by(team_id=team_id).one_or_none()\n                if not team:\n                    error_logger.warning(\n                        f\"Team with ID {team_id} not found while populate round score for game ID {game_id}. Skipping score insertion.\")\n                    continue\n\n                round_score = session.query(RoundScore).filter_by(game_id=game_id, team_id=team_id).one_or_none()\n                if not round_score:\n                    round_score = RoundScore(game_id=game_id, team_id=team_id)\n                    is_created = True\n                else:\n                    is_created = False\n\n                round_score.score = score_data.get('score', round_score.score)\n\n                if is_created:\n                    session.add(round_score)\n                    info_logger.info(f\"New round score added for game {game_id} and team {team_id}.\")\n                else:\n                    info_logger.info(f\"Existing round score updated for game {game_id} and team {team_id}.\")\n\n            session.commit()\n            info_logger.info(f\"Round scores for game {game_id} have been populated.\")\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate round score for game id: {game_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing round score for game id: {game_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "round_score_data",
      "game_id"
    ],
    "missing_params": [
      "session",
      "round_score_data",
      "game_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "round_score_data": "List[Dict[str, Any]]",
      "game_id": "Optional[int]"
    },
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'round_score_data', 'game_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_player_result",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, players_result_data: List[Dict[str, Any]], game_id: Optional[int]",
    "docstring": null,
    "description": null,
    "first_lines": "        if not game_id:\n            error_logger.error(\"No game_id provided for player results.\")\n            return\n\n        for player_data in players_result_data:",
    "lineno": 712,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_player_result(self, session: Session, players_result_data: List[Dict[str, Any]], game_id: Optional[int]) -> None:\n        if not game_id:\n            error_logger.error(\"No game_id provided for player results.\")\n            return\n\n        for player_data in players_result_data:\n            player_info = player_data.get('player')\n            if not player_info:\n                continue\n\n            player_id = player_info.get('id')\n            if not player_id:\n                info_logger.warning(\"Player ID is missing in the data\")\n                continue\n\n            try:\n                player_result = session.query(PlayerResult).filter_by(player_id=player_id,\n                                                                      game_id=game_id).one_or_none()\n\n                if player_result:\n                    info_logger.info(\n                        f\"Existing player result found for player_id: {player_id} and game_id: {game_id}. Skipping \"\n                        f\"creation.\")\n                    continue\n                info_logger.info(f\"Creating new player result for player_id: {player_id} and game_id: {game_id}\")\n\n                player = session.query(Player).filter_by(player_id=player_id).one_or_none()\n                if not player:\n                    info_logger.info(f\"Player not found. Creating new player with ID {player_id}.\")\n                    team_data = player_data.get('team')\n                    team_id = team_data.get('id') if team_data else None\n                    if team_id:\n                        team = session.query(Team).filter_by(team_id=team_data.get('id')).one_or_none()\n                        if not team:\n                            self.populate_team(session, team_data=team_data)\n                            team = session.query(Team).filter_by(team_id=team_data.get('id')).one_or_none()\n                            if not team:\n                                error_logger.warning(\n                                    f\"Team with ID {team_data.get('id')} not found even after population. Skipping \"\n                                    f\"player insertion.\")\n                                continue\n                    self.populate_player(session, player_info, team_id=team.team_id if team else None)\n\n                player_result = PlayerResult(player_id=player_id, game_id=game_id)\n                for key, value in player_data.items():\n                    if key not in ['player', 'team', 'opponent']:\n                        setattr(player_result, key, value)\n                session.add(player_result)\n                session.commit()\n                info_logger.info(f\"New player result added for player {player_id} and game {game_id}.\")\n\n            except SQLAlchemyError as error:\n                session.rollback()\n                error_logger.error(\n                    f\"Failed to populate player result for player with ID {player_id}. Error: {str(error)}\")\n                raise\n\n            except requests.exceptions.RequestException as req_error:\n                session.rollback()\n                error_logger.error(\n                    f\"HTTP request error while fetching player stats for player with ID {player_id}. Error: {str(req_error)}\")\n                raise\n\n            except KeyError as key_error:\n                session.rollback()\n                error_logger.error(\n                    f\"KeyError occurred while processing player result for player ID {player_id} and game ID {game_id}: {str(key_error)}. Player data: {player_data}\")\n                raise\n\n            except Exception as exception:\n                session.rollback()\n                error_logger.error(\n                    f\"An unexpected error occurred while processing player result for player ID {player_id}: {str(exception)}\")\n                raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "players_result_data",
      "game_id"
    ],
    "missing_params": [
      "session",
      "players_result_data",
      "game_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "players_result_data": "List[Dict[str, Any]]",
      "game_id": "Optional[int]"
    },
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'players_result_data', 'game_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_player_stats",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, player_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "        try:\n            player_stats_data = self.make_request(url=self.get_particular_player_stats_url(player_id=player_id))\n            player_stats_data = player_stats_data.json()\n\n            # Map player_stats_data to the PlayerStats model",
    "lineno": 787,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_player_stats(self, session: Session, player_id: int):\n        try:\n            player_stats_data = self.make_request(url=self.get_particular_player_stats_url(player_id=player_id))\n            player_stats_data = player_stats_data.json()\n\n            # Map player_stats_data to the PlayerStats model\n            player_stats_data_mapped = {\n                'assists': player_stats_data['stats']['counts']['assists'],\n                'deaths': player_stats_data['stats']['counts']['deaths'],\n                'first_kills_diff': player_stats_data['stats']['counts']['first_kills_diff'],\n                'flash_assists': player_stats_data['stats']['counts']['flash_assists'],\n                'games_draw': player_stats_data['stats']['counts']['games_draw'],\n                'games_lost': player_stats_data['stats']['counts']['games_lost'],\n                'games_played': player_stats_data['stats']['counts']['games_played'],\n                'games_won': player_stats_data['stats']['counts']['games_won'],\n                'headshots': player_stats_data['stats']['counts']['headshots'],\n                'k_d_diff': player_stats_data['stats']['counts']['k_d_diff'],\n                'kills': player_stats_data['stats']['counts']['kills'],\n                'matches_draw': player_stats_data['stats']['counts']['matches_draw'],\n                'matches_lost': player_stats_data['stats']['counts']['matches_lost'],\n                'matches_played': player_stats_data['stats']['counts']['matches_played'],\n                'matches_won': player_stats_data['stats']['counts']['matches_won'],\n                'rounds_played': player_stats_data['stats']['counts']['rounds_played'],\n                'adr_per_game': player_stats_data['stats']['per_game_averages']['adr'],\n                'assists_per_game': player_stats_data['stats']['per_game_averages']['assists'],\n                'deaths_per_game': player_stats_data['stats']['per_game_averages']['deaths'],\n                'first_kills_diff_per_game': player_stats_data['stats']['per_game_averages']['first_kills_diff'],\n                'flash_assists_per_game': player_stats_data['stats']['per_game_averages']['flash_assists'],\n                'headshots_per_game': player_stats_data['stats']['per_game_averages']['headshots'],\n                'hltv_game_rating': player_stats_data['stats']['per_game_averages']['hltv_game_rating'],\n                'k_d_diff_per_game': player_stats_data['stats']['per_game_averages']['k_d_diff'],\n                'kast_per_game': player_stats_data['stats']['per_game_averages']['kast'],\n                'kills_per_game': player_stats_data['stats']['per_game_averages']['kills'],\n                'assists_per_round': player_stats_data['stats']['per_round_averages']['assists'],\n                'deaths_per_round': player_stats_data['stats']['per_round_averages']['deaths'],\n                'first_kills_diff_per_round': player_stats_data['stats']['per_round_averages']['first_kills_diff'],\n                'flash_assists_per_round': player_stats_data['stats']['per_round_averages']['flash_assists'],\n                'headshots_per_round': player_stats_data['stats']['per_round_averages']['headshots'],\n                'k_d_diff_per_round': player_stats_data['stats']['per_round_averages']['k_d_diff'],\n                'kills_per_round': player_stats_data['stats']['per_round_averages']['kills'],\n            }\n\n            # Fetch the existing player stats from the database\n            existing_player_stats = session.query(PlayerStats).filter_by(player_id=player_id).one_or_none()\n\n            # Check if player stats need to be updated\n            if existing_player_stats:\n                if self.compare_and_update(existing_player_stats, player_stats_data_mapped):\n                    info_logger.info(f\"Player stats updated for player {player_id}.\")\n            else:\n                player_stats = PlayerStats(player_id=player_id, **player_stats_data_mapped)\n                session.add(player_stats)\n                info_logger.info(f\"New player stats added for player {player_id}.\")\n\n            # Commit the changes to the database\n            session.commit()\n\n        except requests.exceptions.RequestException as req_error:\n            error_logger.error(\n                f\"HTTP request error while fetching player stats for player ID {player_id}. Error: {str(req_error)}\")\n\n        except SQLAlchemyError as db_error:\n            session.rollback()\n            error_logger.error(\n                f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n\n        except KeyError as key_error:\n            error_logger.error(\n                f\"KeyError occurred while processing player stats for player ID {player_id}: {str(key_error)}. \"\n                f\"Response: {player_stats_data}\")\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(\n                f\"An unexpected error occurred while processing player stats for player ID {player_id}: {str(exception)}\")",
    "documented_params": [],
    "actual_params": [
      "session",
      "player_id"
    ],
    "missing_params": [
      "session",
      "player_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "player_id": "int"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'player_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.populate_stream",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, session: Session, stream_data: Dict[str, Any]",
    "docstring": null,
    "description": null,
    "first_lines": "        stream_id: int = stream_data.get('id')\n        is_created = False\n\n        try:\n            stream = session.query(Stream).filter_by(id=stream_id).one_or_none()",
    "lineno": 862,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def populate_stream(self, session: Session, stream_data: Dict[str, Any]) -> Optional[Stream]:\n        stream_id: int = stream_data.get('id')\n        is_created = False\n\n        try:\n            stream = session.query(Stream).filter_by(id=stream_id).one_or_none()\n\n            if stream is None:\n                stream = Stream(id=stream_id)\n                is_created = True\n\n            stream_data_mapped = {\n                'embed_url': stream_data.get('embed_url'),\n                'language': stream_data.get('language'),\n                'main': stream_data.get('main'),\n                'official': stream_data.get('official'),\n                'raw_url': stream_data.get('raw_url'),\n                'match_id': stream_data.get('match_id')\n            }\n\n            if is_created:\n                for key, value in stream_data_mapped.items():\n                    setattr(stream, key, value)\n                session.add(stream)\n            else:\n                if self.compare_and_update(stream, stream_data_mapped):\n                    info_logger.info(f\"Stream updated with ID {stream_id}\")\n            session.commit()\n\n            if is_created:\n                info_logger.info(f\"New stream created with ID {stream_id}.\")\n            else:\n                info_logger.info(f\"Existing stream with ID {stream_id} updated.\")\n\n            return stream\n\n        except SQLAlchemyError as error:\n            session.rollback()\n            error_logger.error(f\"Failed to populate stream {stream_id}. Error: {str(error)}\")\n            raise\n\n        except Exception as exception:\n            session.rollback()\n            error_logger.error(f\"An unexpected error occurred while processing stream {stream_id}: {str(exception)}\")\n            raise",
    "documented_params": [],
    "actual_params": [
      "session",
      "stream_data"
    ],
    "missing_params": [
      "session",
      "stream_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "session": "Session",
      "stream_data": "Dict[str, Any]"
    },
    "return_type": "Optional[Stream]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['session', 'stream_data']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "PlayerUpdater.main_population",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, fetched_data: List[Dict[str, Any]]",
    "docstring": null,
    "description": null,
    "first_lines": "        with self.database_manager.get_session() as session:\n            teams_ids = set()\n            processed_tournaments = set()\n            processed_matches = set()\n            processed_teams = set()",
    "lineno": 908,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def main_population(self, fetched_data: List[Dict[str, Any]]) -> None:\n        with self.database_manager.get_session() as session:\n            teams_ids = set()\n            processed_tournaments = set()\n            processed_matches = set()\n            processed_teams = set()\n            processed_players = set()\n            processed_games = set()\n            match_counter = 0\n\n            for match in fetched_data:\n\n                match_id = match.get('id')\n                if match_id in processed_matches:\n                    info_logger.info(f\"Skipping already processed match with ID {match_id}\")\n                    continue\n\n                try:\n                    # tournament populates league and series info altogether\n                    tournament_data = match.get('tournament')\n                    tournament_id = tournament_data.get('id')\n                    if tournament_id not in processed_tournaments:\n                        # Match is passed as a parameter because league and series is populates altogether\n                        self.populate_tournament(session, match)\n                        processed_tournaments.add(tournament_id)\n                    self.populate_match(session, match)\n                    processed_matches.add(match_id)\n\n                    teams_pair = match.get('opponents')\n                    for team in teams_pair:\n                        try:\n                            team_id = team.get('opponent').get('id')\n                            if team_id in processed_teams:\n                                info_logger.info(f\"Skipping already processed team with ID {team_id}\")\n                                continue\n\n                            self.populate_team(session, team.get('opponent'), tournament_id=tournament_id)\n                            teams_ids.add(team_id)\n                            teams_response = self.make_request(url=self.get_particular_team_url(team_id=team_id)).json()\n                            processed_teams.add(team_id)\n\n                            for player in teams_response.get('players'):\n                                player_id = player.get('id')\n                                if player_id in processed_players:\n                                    info_logger.info(f\"Skipping already processed player with ID {player_id}\")\n                                    continue\n                                try:\n\n                                    self.populate_player(session, player, team_id=team_id)\n                                    processed_players.add(player_id)\n                                    last_70_games = self.fetch_last_games(player_id=player_id)\n                                    for game_id in last_70_games:\n                                        if game_id in processed_games:\n                                            info_logger.info(f\"Skipping already processed game with ID {game_id}\")\n                                            continue\n                                        try:\n                                            game_response = self.make_request(\n                                                url=self.get_particular_game_stats_url(game_id)).json()\n                                            match_data = game_response.get('match') or \"Match_data has some issues\"\n                                            rounds_scores_data = game_response.get(\n                                                'rounds_score') or \"Round scores data missing\"\n                                            players_results_data = game_response.get(\n                                                'players') or \"Players results data missing\"\n\n                                            new_tournament_data = match_data.get(\n                                                'tournament') if match_data != \"Match_data has some issues\" else \"Tournament data missing\"\n                                            new_tournament_id = new_tournament_data.get(\n                                                'id') if new_tournament_data else None\n                                            if new_tournament_id and new_tournament_id not in processed_tournaments:\n                                                self.populate_tournament(session, match_data)\n                                                processed_tournaments.add(new_tournament_id)\n                                            new_match_id = match_data.get('id') or \"new_match_id is None\"\n                                            if new_match_id and new_match_id not in processed_matches:\n                                                self.populate_match(session, match_data)\n                                                processed_matches.add(new_match_id)\n\n                                            self.populate_game(session, game_response,\n                                                               match_id=game_response.get('match_id', None))\n                                            self.populate_round_score(session, round_score_data=rounds_scores_data,\n                                                                      game_id=game_response.get('id', None))\n                                            self.populate_player_result(session, players_results_data,\n                                                                        game_id=game_response.get('id'))\n                                            processed_games.add(game_id)\n                                            info_logger.info(f\"Finished processing game with ID {game_id}\")\n\n                                        except requests.exceptions.RequestException as req_error:\n                                            error_logger.error(\n                                                f\"HTTP request error while fetching game stats for game ID {game_id}. Error: {str(req_error)}\")\n                                        except psycopg2_errors.NotNullViolation as db_error:\n                                            error_logger.error(\n                                                f\"Database error while processing game stats for game ID {game_id}: {str(db_error)}\")\n                                        except KeyError as key_error:\n                                            error_logger.error(\n                                                f\"KeyError occurred while processing game stats for game ID {game_id}: {str(key_error)}. Response: {game_response}\")\n                                        except Exception as exception:\n                                            error_logger.error(\n                                                f\"An unexpected error occurred while processing game stats for game ID {game_id}: {str(exception)}\")\n\n                                except requests.exceptions.RequestException as req_error:\n                                    error_logger.error(\n                                        f\"HTTP request error while fetching player stats for player ID {player_id}. Error: {str(req_error)}\")\n                                except psycopg2_errors.NotNullViolation as db_error:\n                                    error_logger.error(\n                                        f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                                except KeyError as key_error:\n                                    error_logger.error(\n                                        f\"KeyError occurred while processing player stats for player ID {player_id}: {str(key_error)}. Response: {player}\")\n                                except Exception as exception:\n                                    error_logger.error(\n                                        f\"An unexpected error occurred while processing player stats for player ID {player_id}: {str(exception)}\")\n\n                                self.populate_player_stats(session, player_id=player_id)\n\n                        except requests.exceptions.RequestException as req_error:\n                            error_logger.error(\n                                f\"HTTP request error while fetching team stats for team ID {team_id}. Error: {str(req_error)}\")\n                        except psycopg2_errors.NotNullViolation as db_error:\n                            error_logger.error(\n                                f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                        except KeyError as key_error:\n                            error_logger.error(\n                                f\"KeyError occurred while processing team stats for team ID {team_id}: {str(key_error)}. Response: {team}\")\n                        except RetryError as retry_error:\n                            error_logger.error(\n                                f\"RetryError occurred while fetching team stats for team ID {team_id}. Error: {retry_error}\")\n                            if retry_error.last_attempt:\n                                error_logger.error(f\"Last attempt exception: {retry_error.last_attempt.exception()}\")\n                            raise\n                        except Exception as exception:\n                            error_logger.error(\n                                f\"An unexpected error occurred while processing team stats for team ID {team_id}: {str(exception)}\")\n\n                    match_counter += 1\n                    info_logger.info(f\"Processed until now {match_counter} matches.\")\n                except requests.exceptions.RequestException as req_error:\n                    error_logger.error(\n                        f\"HTTP request error while fetching match stats for match ID {match_id}. Error: {str(req_error)}\")\n                except psycopg2_errors.NotNullViolation as db_error:\n                    error_logger.error(\n                        f\"Database error while processing player stats for player ID {player_id}: {str(db_error)}\")\n                except KeyError as key_error:\n                    error_logger.error(\n                        f\"KeyError occurred while processing match stats for match ID {match_id}: {str(key_error)}. Response: {match}\")\n                except Exception as exception:\n                    error_logger.error(\n                        f\"An unexpected error occurred while processing match stats for match ID {match_id}: {str(exception)}\")",
    "documented_params": [],
    "actual_params": [
      "fetched_data"
    ],
    "missing_params": [
      "fetched_data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "fetched_data": "List[Dict[str, Any]]"
    },
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['fetched_data']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "api_updater",
    "qualname": "run_api_updater",
    "path": "",
    "method": "FUNCTION",
    "signature": "db_user: str, db_password: str, db_host: str, db_port: str, db_name: str, pandascore_api_token: str",
    "docstring": null,
    "description": null,
    "first_lines": "    start = time.time()\n    info_logger.info(f\"API Updater start: {start}\")\n    try:\n        player_updater = PlayerUpdater(api_token=pandascore_api_token, user=db_user, password=db_password, host=db_host, port=db_port, db_name=db_name)\n        upcoming_matches = player_updater.get_upcoming_matches()",
    "lineno": 1056,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api_updater.py",
    "full_source": "def run_api_updater(db_user: str, db_password: str, db_host: str, db_port: str, db_name: str, pandascore_api_token: str):\n    start = time.time()\n    info_logger.info(f\"API Updater start: {start}\")\n    try:\n        player_updater = PlayerUpdater(api_token=pandascore_api_token, user=db_user, password=db_password, host=db_host, port=db_port, db_name=db_name)\n        upcoming_matches = player_updater.get_upcoming_matches()\n        info_logger.info(f\"Number of upcoming matches: {len(upcoming_matches)}\")\n        player_updater.main_population(upcoming_matches)\n    except Exception as exception:\n        error_logger.error(f\"An error occurred: {exception}\")\n        info_logger.info(f\"Process encountered an exception after {time.time() - start} seconds.\")\n        raise\n    end = time.time()\n    duration = end - start\n    info_logger.info(f\"API Updater process completed in {duration} seconds.\")",
    "documented_params": [],
    "actual_params": [
      "db_user",
      "db_password",
      "db_host",
      "db_port",
      "db_name",
      "pandascore_api_token"
    ],
    "missing_params": [
      "db_user",
      "db_password",
      "db_host",
      "db_port",
      "db_name",
      "pandascore_api_token"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "db_user": "str",
      "db_password": "str",
      "db_host": "str",
      "db_port": "str",
      "db_name": "str",
      "pandascore_api_token": "str"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['db_user', 'db_password', 'db_host', 'db_port', 'db_name', 'pandascore_api_token']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 70.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "MatchStatuses",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Enum)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 18,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "class MatchStatuses(Enum):\n    FINISHED = \"finished\"\n    NOT_STARTED = \"not_started\"",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "upcoming_matches",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    matches = db.query(Match).where(Match.status == MatchStatuses.NOT_STARTED.value).join(Match.tournament).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n",
    "lineno": 32,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def upcoming_matches(db: Session = Depends(get_db)):\n    matches = db.query(Match).where(Match.status == MatchStatuses.NOT_STARTED.value).join(Match.tournament).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    return matches",
    "documented_params": [],
    "actual_params": [
      "db"
    ],
    "missing_params": [
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "upcoming_matches",
    "path": "/database/upcoming-matches",
    "method": "GET",
    "signature": "db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    matches = db.query(Match).where(Match.status == MatchStatuses.NOT_STARTED.value).join(Match.tournament).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n",
    "lineno": 32,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def upcoming_matches(db: Session = Depends(get_db)):\n    matches = db.query(Match).where(Match.status == MatchStatuses.NOT_STARTED.value).join(Match.tournament).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    return matches",
    "documented_params": [],
    "actual_params": [
      "db"
    ],
    "missing_params": [
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": "List[MatchBase]",
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 48.0
  },
  {
    "module": "test_routers",
    "qualname": "all_players_list",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        players = db.query(Player).all()\n        if not players:\n            raise HTTPException(status_code=404, detail=\"No players found\")\n        return players",
    "lineno": 42,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def all_players_list(db: Session = Depends(get_db)):\n    try:\n        players = db.query(Player).all()\n        if not players:\n            raise HTTPException(status_code=404, detail=\"No players found\")\n        return players\n    except Exception as exception:\n        raise HTTPException(status_code=500, detail=str(exception))",
    "documented_params": [],
    "actual_params": [
      "db"
    ],
    "missing_params": [
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "all_players_list",
    "path": "/database/all-players",
    "method": "GET",
    "signature": "db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        players = db.query(Player).all()\n        if not players:\n            raise HTTPException(status_code=404, detail=\"No players found\")\n        return players",
    "lineno": 42,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def all_players_list(db: Session = Depends(get_db)):\n    try:\n        players = db.query(Player).all()\n        if not players:\n            raise HTTPException(status_code=404, detail=\"No players found\")\n        return players\n    except Exception as exception:\n        raise HTTPException(status_code=500, detail=str(exception))",
    "documented_params": [],
    "actual_params": [
      "db"
    ],
    "missing_params": [
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": "List[PlayerBase]",
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 48.0
  },
  {
    "module": "test_routers",
    "qualname": "add_player_to_team",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "team_id: str, player_id: str, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:",
    "lineno": 53,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def add_player_to_team(team_id: str, player_id: str, db: Session = Depends(get_db)):\n    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:\n        raise HTTPException(status_code=404, detail=\"Player not found\")\n    if player in team.players:\n        raise HTTPException(status_code=400, detail=\"Player already in team\")\n    team.players.append(player)\n    db.commit()\n    return {\"detail\": f\"Player {player_id} added to team {team_id}\"}",
    "documented_params": [],
    "actual_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "missing_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "str",
      "player_id": "str",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id', 'player_id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "add_player_to_team",
    "path": "/database/teams/{team_id}/players/{player_id}",
    "method": "POST",
    "signature": "team_id: str, player_id: str, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:",
    "lineno": 53,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def add_player_to_team(team_id: str, player_id: str, db: Session = Depends(get_db)):\n    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:\n        raise HTTPException(status_code=404, detail=\"Player not found\")\n    if player in team.players:\n        raise HTTPException(status_code=400, detail=\"Player already in team\")\n    team.players.append(player)\n    db.commit()\n    return {\"detail\": f\"Player {player_id} added to team {team_id}\"}",
    "documented_params": [],
    "actual_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "missing_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "str",
      "player_id": "str",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id', 'player_id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 40.0
  },
  {
    "module": "test_routers",
    "qualname": "remove_player_from_team",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "team_id: str, player_id: str, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:",
    "lineno": 68,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def remove_player_from_team(team_id: str, player_id: str, db: Session = Depends(get_db)):\n    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:\n        raise HTTPException(status_code=404, detail=\"Player not found\")\n    if player not in team.players:\n        raise HTTPException(status_code=400, detail=\"Player not in team\")\n    team.players.remove(player)\n    db.commit()\n    return {\"detail\": f\"Player {player_id} removed from team {team_id}\"}",
    "documented_params": [],
    "actual_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "missing_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "str",
      "player_id": "str",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id', 'player_id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "remove_player_from_team",
    "path": "/database/teams/{team_id}/players/{player_id}",
    "method": "DELETE",
    "signature": "team_id: str, player_id: str, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:",
    "lineno": 68,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def remove_player_from_team(team_id: str, player_id: str, db: Session = Depends(get_db)):\n    team = db.query(Team).filter(Team.team_id == team_id).first()\n    if not team:\n        raise HTTPException(status_code=404, detail=\"Team not found\")\n    player = db.query(Player).filter(Player.player_id == player_id).first()\n    if not player:\n        raise HTTPException(status_code=404, detail=\"Player not found\")\n    if player not in team.players:\n        raise HTTPException(status_code=400, detail=\"Player not in team\")\n    team.players.remove(player)\n    db.commit()\n    return {\"detail\": f\"Player {player_id} removed from team {team_id}\"}",
    "documented_params": [],
    "actual_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "missing_params": [
      "team_id",
      "player_id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "str",
      "player_id": "str",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id', 'player_id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 40.0
  },
  {
    "module": "test_routers",
    "qualname": "get_roster_url",
    "path": "",
    "method": "FUNCTION",
    "signature": "tournament_id",
    "docstring": null,
    "description": null,
    "first_lines": "    return f\"https://api.pandascore.co/tournaments/{tournament_id}/rosters\"",
    "lineno": 82,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "def get_roster_url(tournament_id):\n    return f\"https://api.pandascore.co/tournaments/{tournament_id}/rosters\"",
    "documented_params": [],
    "actual_params": [
      "tournament_id"
    ],
    "missing_params": [
      "tournament_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['tournament_id']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "fetch_rosters",
    "path": "",
    "method": "FUNCTION",
    "signature": "tournament_id",
    "docstring": null,
    "description": null,
    "first_lines": "    response = requests.get(get_roster_url(tournament_id), headers=HEADERS)\n    response.raise_for_status()\n    return response.json()",
    "lineno": 86,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "def fetch_rosters(tournament_id):\n    response = requests.get(get_roster_url(tournament_id), headers=HEADERS)\n    response.raise_for_status()\n    return response.json()",
    "documented_params": [],
    "actual_params": [
      "tournament_id"
    ],
    "missing_params": [
      "tournament_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['tournament_id']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "get_player_avg_kills_data",
    "path": "",
    "method": "FUNCTION",
    "signature": "player_id: int, db: Session, x_maps: int",
    "docstring": null,
    "description": null,
    "first_lines": "    player_stats = (db.query(PlayerResult)\n                    .filter_by(player_id=player_id)\n                    .order_by(PlayerResult.game_id.desc())\n                    .limit(x_maps)\n                    .all()",
    "lineno": 91,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "def get_player_avg_kills_data(player_id: int, db: Session, x_maps: int) ->List[Dict]:\n    player_stats = (db.query(PlayerResult)\n                    .filter_by(player_id=player_id)\n                    .order_by(PlayerResult.game_id.desc())\n                    .limit(x_maps)\n                    .all()\n                    )\n    team_stats = {}\n    for stat in player_stats:\n        match = db.query(Match).filter(Match.match_id ==stat.game_id).one_or_none()\n        print(f\"match: {match}\")\n        time.sleep(120)\n        if not match:\n            continue\n\n        player_team = None\n        for team in match.teams:\n            if player_id in [p.player_id for p in team.players]:\n                player_team = team\n                break\n        if not player_team:\n            continue\n\n        team_id = player_team.team_id\n        team_name = player_team.name\n\n        if team_id not in team_stats:\n            team_stats[team_id] = {\n                \"team\": {\"team_id\": team_id, \"name\": team_name},\n                \"games\": 0,\n                \"total_kills\": 0\n            }\n\n        team_stats[team_id][\"games\"] +=1\n        team_stats[team_id][\"total_kills\"] += stat.kills\n\n        avg_kills_data_source = []\n        for team_stat in team_stats.values():\n            games = team_stat[\"games\"]\n            total_kills = team_stat[\"total_kills\"]\n            avg_kills = total_kills/games if games else 0\n            team_stat[\"avg_kills\"] = round(avg_kills, 3)\n            del team_stat[\"total_kills\"]\n            avg_kills_data_source.append(team_stat)\n\n        return avg_kills_data_source",
    "documented_params": [],
    "actual_params": [
      "player_id",
      "db",
      "x_maps"
    ],
    "missing_params": [
      "player_id",
      "db",
      "x_maps"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "player_id": "int",
      "db": "Session",
      "x_maps": "int"
    },
    "return_type": "List[Dict]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['player_id', 'db', 'x_maps']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "fetch_match_info",
    "path": "",
    "method": "FUNCTION",
    "signature": "match, rosters, db, x_maps",
    "docstring": null,
    "description": null,
    "first_lines": "    match_info = {\n        \"match_id\": match.match_id,\n        \"teams\": []\n    }\n",
    "lineno": 138,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "def fetch_match_info(match, rosters, db, x_maps):\n    match_info = {\n        \"match_id\": match.match_id,\n        \"teams\": []\n    }\n\n    for team in match.teams:\n        team_info = {\n            \"team_id\": team.team_id,\n            \"team_name\": team.name,\n            \"players\": []\n        }\n\n        for roster in rosters.get('rosters', []):\n            if roster.get('id') == team.team_id:\n                for roster_player in roster.get('players'):\n                    player = db.query(Player).filter_by(player_id=roster_player.get('id')).one_or_none()\n                    if player:\n                        player_info = {\n                            \"player_id\": player.player_id,\n                            \"player_name\": player.name,\n                            \"kills\": 0,\n                            \"headshots\": 0,\n                            \"weighted_avg_kills\": 0,\n                            \"headshots_percentage\": 0,\n                            \"playing\": True\n                        }\n\n                        # Fetch player stats from the last 70 games from the database\n                        player_stats = db.query(PlayerResult).filter_by(player_id=player.player_id).order_by(\n                            PlayerResult.game_id.desc()).limit(70).all()\n\n                        total_kills = sum(stat.kills for stat in player_stats)\n                        total_headshots = sum(stat.headshots for stat in player_stats)\n                        total_games = len(player_stats)\n\n                        # Calculate total rounds played\n                        total_rounds = db.query(RoundScore).filter(RoundScore.game_id.in_(\n                            [stat.game_id for stat in player_stats]\n                        )).count()\n\n                        player_info[\"kills\"] = total_kills\n                        player_info[\"headshots\"] = total_headshots\n\n                        # Calculate weighted average kills and headshot percentage\n                        sum_kills_70 = total_kills\n                        sum_kills_40 = sum(stat.kills for stat in player_stats[:40])\n                        sum_rounds_70 = total_rounds\n                        sum_rounds_40 = db.query(RoundScore).filter(RoundScore.game_id.in_(\n                            [stat.game_id for stat in player_stats[:40]]\n                        )).count()\n                        sum_headshots = total_headshots\n\n                        if total_rounds > 0:\n                            weighted_avg_kills = (sum_kills_70 / sum_rounds_70 * 0.5) + (\n                                    sum_kills_40 / sum_rounds_40 * 0.5)\n                            player_info[\"weighted_avg_kills\"] = round(weighted_avg_kills, 3)\n\n                            headshot_percentage = (sum_headshots / sum_kills_70 * 100) if sum_kills_70 else 0\n                            player_info[\"headshots_percentage\"] = round(headshot_percentage, 2)\n\n                        avg_kills_data_source = get_player_avg_kills_data(player.player_id, db, x_maps)\n                        if len(avg_kills_data_source) > 1:\n                            player_info[\"avg_kills_data_source\"] = avg_kills_data_source\n\n                        team_info[\"players\"].append(player_info)\n\n        match_info[\"teams\"].append(team_info)\n\n    return match_info",
    "documented_params": [],
    "actual_params": [
      "match",
      "rosters",
      "db",
      "x_maps"
    ],
    "missing_params": [
      "match",
      "rosters",
      "db",
      "x_maps"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['match', 'rosters', 'db', 'x_maps']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 80.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "upcoming_matches_with_rosters_and_stats",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "match_id: int=None, x_maps: int=Query(..., gt=0, description='Number of recent maps to consider for statistics'), db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "        match_id: int = None,\n        x_maps: int = Query(..., gt=0, description=\"Number of recent maps to consider for statistics\"),\n        db: Session = Depends(get_db)):\n    if match_id:\n        matches = db.query(Match).filter(Match.match_id == match_id).all()",
    "lineno": 211,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def upcoming_matches_with_rosters_and_stats(\n        match_id: int = None,\n        x_maps: int = Query(..., gt=0, description=\"Number of recent maps to consider for statistics\"),\n        db: Session = Depends(get_db)):\n    if match_id:\n        matches = db.query(Match).filter(Match.match_id == match_id).all()\n    else:\n        current_time = datetime.utcnow()\n        matches = db.query(Match).filter(Match.begin_at >= current_time).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    upcoming_matches = []\n\n    for match in matches:\n        tournament_id = match.tournament_id\n        rosters = fetch_rosters(tournament_id)\n        match_info = fetch_match_info(match, rosters, db, x_maps)\n        upcoming_matches.append(match_info)\n\n    if not upcoming_matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    return upcoming_matches",
    "documented_params": [],
    "actual_params": [
      "match_id",
      "x_maps",
      "db"
    ],
    "missing_params": [
      "match_id",
      "x_maps",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "match_id": "int",
      "x_maps": "int",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['match_id', 'x_maps', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "upcoming_matches_with_rosters_and_stats",
    "path": "/database/upcoming-matches-with-rosters-and-stats",
    "method": "GET",
    "signature": "match_id: int=None, x_maps: int=Query(..., gt=0, description='Number of recent maps to consider for statistics'), db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "        match_id: int = None,\n        x_maps: int = Query(..., gt=0, description=\"Number of recent maps to consider for statistics\"),\n        db: Session = Depends(get_db)):\n    if match_id:\n        matches = db.query(Match).filter(Match.match_id == match_id).all()",
    "lineno": 211,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def upcoming_matches_with_rosters_and_stats(\n        match_id: int = None,\n        x_maps: int = Query(..., gt=0, description=\"Number of recent maps to consider for statistics\"),\n        db: Session = Depends(get_db)):\n    if match_id:\n        matches = db.query(Match).filter(Match.match_id == match_id).all()\n    else:\n        current_time = datetime.utcnow()\n        matches = db.query(Match).filter(Match.begin_at >= current_time).all()\n\n    if not matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    upcoming_matches = []\n\n    for match in matches:\n        tournament_id = match.tournament_id\n        rosters = fetch_rosters(tournament_id)\n        match_info = fetch_match_info(match, rosters, db, x_maps)\n        upcoming_matches.append(match_info)\n\n    if not upcoming_matches:\n        raise HTTPException(status_code=404, detail=\"No upcoming matches found\")\n\n    return upcoming_matches",
    "documented_params": [],
    "actual_params": [
      "match_id",
      "x_maps",
      "db"
    ],
    "missing_params": [
      "match_id",
      "x_maps",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "match_id": "int",
      "x_maps": "int",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['match_id', 'x_maps', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 40.0
  },
  {
    "module": "test_routers",
    "qualname": "match_players_stats",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "id: int, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    match = db.query(Match).filter(Match.match_id == id).one_or_none()\n\n    if not match:\n        raise HTTPException(status_code=404, detail=\"Match not found\")\n",
    "lineno": 239,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def match_players_stats(id: int, db: Session = Depends(get_db)):\n    match = db.query(Match).filter(Match.match_id == id).one_or_none()\n\n    if not match:\n        raise HTTPException(status_code=404, detail=\"Match not found\")\n\n    tournament_id = match.tournament_id\n    rosters = fetch_rosters(tournament_id)\n    match_info = fetch_match_info(match, rosters, db)\n\n    return match_info",
    "documented_params": [],
    "actual_params": [
      "id",
      "db"
    ],
    "missing_params": [
      "id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "id": "int",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "test_routers",
    "qualname": "match_players_stats",
    "path": "/database/match/{id}/players-stats",
    "method": "GET",
    "signature": "id: int, db: Session=Depends(get_db)",
    "docstring": null,
    "description": null,
    "first_lines": "    match = db.query(Match).filter(Match.match_id == id).one_or_none()\n\n    if not match:\n        raise HTTPException(status_code=404, detail=\"Match not found\")\n",
    "lineno": 239,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/test_routers.py",
    "full_source": "async def match_players_stats(id: int, db: Session = Depends(get_db)):\n    match = db.query(Match).filter(Match.match_id == id).one_or_none()\n\n    if not match:\n        raise HTTPException(status_code=404, detail=\"Match not found\")\n\n    tournament_id = match.tournament_id\n    rosters = fetch_rosters(tournament_id)\n    match_info = fetch_match_info(match, rosters, db)\n\n    return match_info",
    "documented_params": [],
    "actual_params": [
      "id",
      "db"
    ],
    "missing_params": [
      "id",
      "db"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "id": "int",
      "db": "Session"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['id', 'db']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [
      "get_db"
    ],
    "dependency_docs": {
      "db": "get_db"
    },
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 40.0
  },
  {
    "module": "main",
    "qualname": "app.middleware",
    "path": "",
    "method": "MIDDLEWARE",
    "signature": "CORSMiddleware",
    "docstring": null,
    "description": "Middleware: CORSMiddleware",
    "first_lines": "",
    "lineno": 13,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "app.router_inclusion",
    "path": "",
    "method": "ROUTER_INCLUSION",
    "signature": "router",
    "docstring": null,
    "description": "Router inclusion: router",
    "first_lines": "",
    "lineno": 21,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "app.router_inclusion",
    "path": "",
    "method": "ROUTER_INCLUSION",
    "signature": "db_router",
    "docstring": null,
    "description": "Router inclusion: db_router",
    "first_lines": "",
    "lineno": 22,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "LeagueBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class LeagueBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    image_url: Optional[HttpUrl]\n    modified_at: datetime\n    name: str\n    slug: str\n    url: Optional[HttpUrl]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "image_url": "Optional[HttpUrl]",
      "modified_at": "datetime",
      "name": "str",
      "slug": "str",
      "url": "Optional[HttpUrl]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "SerieBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 17,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class SerieBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    begin_at: Optional[datetime]\n    end_at: Optional[datetime]\n    full_name: Optional[str]\n    id: int\n    league_id: Optional[int]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    season: Optional[str]\n    slug: Optional[str]\n    winner_id: Optional[int]\n    winner_type: Optional[str]\n    year: Optional[int]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "begin_at": "Optional[datetime]",
      "end_at": "Optional[datetime]",
      "full_name": "Optional[str]",
      "id": "int",
      "league_id": "Optional[int]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "season": "Optional[str]",
      "slug": "Optional[str]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]",
      "year": "Optional[int]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "GameBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 33,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class GameBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    game_id: int\n    match_id: Optional[int] = Field(None, alias='match_id')\n    begin_at: Optional[datetime]\n    complete: Optional[bool]\n    detailed_stats: Optional[bool]\n    end_at: Optional[datetime]\n    forfeit: Optional[bool]\n    length: Optional[int]\n    position: Optional[int]\n    status: Optional[str]\n    winner_id: Optional[int]\n    winner_type: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "game_id": "int",
      "match_id": "Optional[int]",
      "begin_at": "Optional[datetime]",
      "complete": "Optional[bool]",
      "detailed_stats": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "forfeit": "Optional[bool]",
      "length": "Optional[int]",
      "position": "Optional[int]",
      "status": "Optional[str]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "PlayerBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 49,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class PlayerBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    active: Optional[bool]\n    age: Optional[str]\n    first_name: Optional[str]\n    birthday: Optional[str]\n    id: Optional[int]\n    image_url: Optional[HttpUrl]\n    last_name: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    nationality: Optional[str]\n    slug: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "active": "Optional[bool]",
      "age": "Optional[str]",
      "first_name": "Optional[str]",
      "birthday": "Optional[str]",
      "id": "Optional[int]",
      "image_url": "Optional[HttpUrl]",
      "last_name": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "nationality": "Optional[str]",
      "slug": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "PlayerStatsBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 64,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class PlayerStatsBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    player_id: int\n    player: Optional[PlayerBase]\n\n    # Counts\n    assists: Optional[int]\n    deaths: Optional[int]\n    first_kills_diff: Optional[int]\n    flash_assists: Optional[int]\n    games_draw: Optional[int]\n    games_lost: Optional[int]\n    games_played: Optional[int]\n    games_won: Optional[int]\n    headshots: Optional[int]\n    k_d_diff: Optional[int]\n    kills: Optional[int]\n    matches_draw: Optional[int]\n    matches_lost: Optional[int]\n    matches_played: Optional[int]\n    matches_won: Optional[int]\n    rounds_played: Optional[int]\n\n    # Per Game Averages\n    adr_per_game: Optional[float]\n    assists_per_game: Optional[float]\n    deaths_per_game: Optional[float]\n    first_kills_diff_per_game: Optional[float]\n    flash_assists_per_game: Optional[float]\n    headshots_per_game: Optional[float]\n    hltv_game_rating: Optional[float]\n    k_d_diff_per_game: Optional[float]\n    kast_per_game: Optional[float]\n    kills_per_game: Optional[float]\n\n    # Per Round Averages\n    assists_per_round: Optional[float]\n    deaths_per_round: Optional[float]\n    first_kills_diff_per_round: Optional[float]\n    flash_assists_per_round: Optional[float]\n    headshots_per_round: Optional[float]\n    k_d_diff_per_round: Optional[float]\n    kills_per_round: Optional[float]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "player_id": "int",
      "player": "Optional[PlayerBase]",
      "assists": "Optional[int]",
      "deaths": "Optional[int]",
      "first_kills_diff": "Optional[int]",
      "flash_assists": "Optional[int]",
      "games_draw": "Optional[int]",
      "games_lost": "Optional[int]",
      "games_played": "Optional[int]",
      "games_won": "Optional[int]",
      "headshots": "Optional[int]",
      "k_d_diff": "Optional[int]",
      "kills": "Optional[int]",
      "matches_draw": "Optional[int]",
      "matches_lost": "Optional[int]",
      "matches_played": "Optional[int]",
      "matches_won": "Optional[int]",
      "rounds_played": "Optional[int]",
      "adr_per_game": "Optional[float]",
      "assists_per_game": "Optional[float]",
      "deaths_per_game": "Optional[float]",
      "first_kills_diff_per_game": "Optional[float]",
      "flash_assists_per_game": "Optional[float]",
      "headshots_per_game": "Optional[float]",
      "hltv_game_rating": "Optional[float]",
      "k_d_diff_per_game": "Optional[float]",
      "kast_per_game": "Optional[float]",
      "kills_per_game": "Optional[float]",
      "assists_per_round": "Optional[float]",
      "deaths_per_round": "Optional[float]",
      "first_kills_diff_per_round": "Optional[float]",
      "flash_assists_per_round": "Optional[float]",
      "headshots_per_round": "Optional[float]",
      "k_d_diff_per_round": "Optional[float]",
      "kills_per_round": "Optional[float]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "PlayerResultBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 110,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class PlayerResultBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    game_id: int\n    player_id: int\n    adr: Optional[float]\n    assists: Optional[int]\n    deaths: Optional[int]\n    first_kills_diff: Optional[int]\n    flash_assists: Optional[int]\n    headshots: Optional[int]\n    k_d_diff: Optional[int]\n    kast: Optional[float]\n    kills: Optional[int]\n    rating: Optional[float]\n    game: Optional[GameBase]\n    player: Optional[PlayerBase]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "game_id": "int",
      "player_id": "int",
      "adr": "Optional[float]",
      "assists": "Optional[int]",
      "deaths": "Optional[int]",
      "first_kills_diff": "Optional[int]",
      "flash_assists": "Optional[int]",
      "headshots": "Optional[int]",
      "k_d_diff": "Optional[int]",
      "kast": "Optional[float]",
      "kills": "Optional[int]",
      "rating": "Optional[float]",
      "game": "Optional[GameBase]",
      "player": "Optional[PlayerBase]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "StreamBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 129,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class StreamBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    embed_url: Optional[HttpUrl]\n    language: Optional[str]\n    main: bool\n    official: bool\n    raw_url: Optional[HttpUrl]\n    match_id: int",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "embed_url": "Optional[HttpUrl]",
      "language": "Optional[str]",
      "main": "bool",
      "official": "bool",
      "raw_url": "Optional[HttpUrl]",
      "match_id": "int"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "RoundScoreBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 140,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class RoundScoreBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    game_id: int\n    team_id: int\n    score: int\n    game: Optional[GameBase]\n    team: Optional['TeamBase']",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "game_id": "int",
      "team_id": "int",
      "score": "int",
      "game": "Optional[GameBase]",
      "team": "Optional['TeamBase']"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "MatchResultBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 150,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class MatchResultBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    match_id: int\n    team1_id: int\n    team2_id: int\n    score_team1: Optional[int]\n    score_team2: Optional[int]\n    match: Optional['MatchBase']  # Forward reference\n    team1: Optional['TeamBase']  # Forward reference\n    team2: Optional['TeamBase']",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "match_id": "int",
      "team1_id": "int",
      "team2_id": "int",
      "score_team1": "Optional[int]",
      "score_team2": "Optional[int]",
      "match": "Optional['MatchBase']",
      "team1": "Optional['TeamBase']",
      "team2": "Optional['TeamBase']"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "MatchBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 163,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class MatchBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    begin_at: Optional[datetime]\n    detailed_stats: Optional[bool]\n    draw: Optional[bool]\n    end_at: Optional[datetime]\n    forfeit: Optional[bool]\n    game_advantage: Optional[str]\n    match_id: int\n    live: Optional[dict]\n    match_type: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    number_of_games: Optional[int]\n    original_scheduled_at: Optional[datetime]\n    rescheduled: Optional[bool]\n    scheduled_at: Optional[datetime]\n    slug: Optional[str]\n    status: Optional[str]\n    streams_list: List[StreamBase]\n    tournament_id: int\n    winner_id: Optional[int]\n    winner_type: Optional[str]\n    teams: List['TeamBase'] = []",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "begin_at": "Optional[datetime]",
      "detailed_stats": "Optional[bool]",
      "draw": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "forfeit": "Optional[bool]",
      "game_advantage": "Optional[str]",
      "match_id": "int",
      "live": "Optional[dict]",
      "match_type": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "number_of_games": "Optional[int]",
      "original_scheduled_at": "Optional[datetime]",
      "rescheduled": "Optional[bool]",
      "scheduled_at": "Optional[datetime]",
      "slug": "Optional[str]",
      "status": "Optional[str]",
      "streams_list": "List[StreamBase]",
      "tournament_id": "int",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]",
      "teams": "List['TeamBase']"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "TeamBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 189,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class TeamBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    team_id: int = Field(..., alias='id')  # Align with the primary key in SQLAlchemy\n    acronym: Optional[str]\n    image_url: Optional[HttpUrl]\n    location: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    slug: Optional[str]\n    players: Optional[List[PlayerBase]] = []  # Related players\n    tournaments: Optional[List['TournamentBase']] = []",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "team_id": "int",
      "acronym": "Optional[str]",
      "image_url": "Optional[HttpUrl]",
      "location": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "slug": "Optional[str]",
      "players": "Optional[List[PlayerBase]]",
      "tournaments": "Optional[List['TournamentBase']]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "pydantic_models",
    "qualname": "TournamentBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 202,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/pydantic_models.py",
    "full_source": "class TournamentBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    tournament_id: int = Field(..., alias='id')\n    begin_at: Optional[datetime]\n    detailed_stats: Optional[bool]\n    end_at: Optional[datetime]\n    has_bracket: Optional[bool]\n    league_id: Optional[int]\n    live_supported: Optional[bool]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    prizepool: Optional[str]\n    serie_id: Optional[int]\n    slug: Optional[str]\n    tier: Optional[str]\n    videogame: Optional[dict]\n    videogame_title: Optional[dict]\n    winner_id: Optional[int]\n    winner_type: Optional[str]\n    league: Optional[LeagueBase]\n    serie: Optional[SerieBase]\n    matches: Optional[List[MatchBase]]  # Related matches\n    teams: Optional[List[TeamBase]]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "tournament_id": "int",
      "begin_at": "Optional[datetime]",
      "detailed_stats": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "has_bracket": "Optional[bool]",
      "league_id": "Optional[int]",
      "live_supported": "Optional[bool]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "prizepool": "Optional[str]",
      "serie_id": "Optional[int]",
      "slug": "Optional[str]",
      "tier": "Optional[str]",
      "videogame": "Optional[dict]",
      "videogame_title": "Optional[dict]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]",
      "league": "Optional[LeagueBase]",
      "serie": "Optional[SerieBase]",
      "matches": "Optional[List[MatchBase]]",
      "teams": "Optional[List[TeamBase]]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "get_margin",
    "path": "",
    "method": "FUNCTION",
    "signature": "data",
    "docstring": null,
    "description": null,
    "first_lines": "    margin_str = data.get(\"margin\", None)\n    margin_error = None\n\n    if margin_str is None:\n        margin_error = \"Margin value is missing.\"",
    "lineno": 23,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def get_margin(data):\n    margin_str = data.get(\"margin\", None)\n    margin_error = None\n\n    if margin_str is None:\n        margin_error = \"Margin value is missing.\"\n        return 0.0, margin_error\n    else:\n        try:\n            margin = float(margin_str)\n            return margin, ''\n        except ValueError:\n            margin_error = \"Margin value must be a float.\"\n            return 0.0, margin_error",
    "documented_params": [],
    "actual_params": [
      "data"
    ],
    "missing_params": [
      "data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['data']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "calculate_odds_kill",
    "path": "",
    "method": "FUNCTION",
    "signature": "kills: float, margin: float",
    "docstring": null,
    "description": null,
    "first_lines": "    absolute_kills_value = int(kills)\n    threshold_kills = absolute_kills_value + 0.5\n    poisson_distribution = poisson.cdf(absolute_kills_value, kills)\n    survival_probability = 1 - poisson_distribution\n    odds1 = 1 / (",
    "lineno": 39,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def calculate_odds_kill(kills: float, margin: float):\n    absolute_kills_value = int(kills)\n    threshold_kills = absolute_kills_value + 0.5\n    poisson_distribution = poisson.cdf(absolute_kills_value, kills)\n    survival_probability = 1 - poisson_distribution\n    odds1 = 1 / (\n            poisson_distribution\n            / (poisson_distribution + survival_probability)\n            * margin\n    )\n    odds2 = 1 / (\n            survival_probability\n            / (poisson_distribution + survival_probability)\n            * margin\n    )\n\n    return {\n        \"line\": threshold_kills,\n        \"odd1\": round(odds1, 2),\n        \"odd2\": round(odds2, 2),\n    }",
    "documented_params": [],
    "actual_params": [
      "kills",
      "margin"
    ],
    "missing_params": [
      "kills",
      "margin"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "kills": "float",
      "margin": "float"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['kills', 'margin']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "poisson_probabilities",
    "path": "",
    "method": "FUNCTION",
    "signature": "lam",
    "docstring": "Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.",
    "description": null,
    "first_lines": "    \"\"\"Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.\"\"\"\n    return poisson.pmf(np.arange(MAX_KILLS + 1), lam)",
    "lineno": 62,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def poisson_probabilities(lam):\n    \"\"\"Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.\"\"\"\n    return poisson.pmf(np.arange(MAX_KILLS + 1), lam)",
    "documented_params": [],
    "actual_params": [
      "lam"
    ],
    "missing_params": [
      "lam"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['lam']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 84,
    "complexity_score": 65.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "create_probability_matrix",
    "path": "",
    "method": "FUNCTION",
    "signature": "player_a_probs, player_b_probs",
    "docstring": "Use numpy to efficiently create a probability matrix for two players.",
    "description": null,
    "first_lines": "    \"\"\"Use numpy to efficiently create a probability matrix for two players.\"\"\"\n    return np.outer(player_a_probs, player_b_probs)",
    "lineno": 67,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def create_probability_matrix(player_a_probs, player_b_probs):\n    \"\"\"Use numpy to efficiently create a probability matrix for two players.\"\"\"\n    return np.outer(player_a_probs, player_b_probs)",
    "documented_params": [],
    "actual_params": [
      "player_a_probs",
      "player_b_probs"
    ],
    "missing_params": [
      "player_a_probs",
      "player_b_probs"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['player_a_probs', 'player_b_probs']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 69,
    "complexity_score": 70.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "calculate_total_probabilities",
    "path": "",
    "method": "FUNCTION",
    "signature": "prob_matrix",
    "docstring": "Calculate total probabilities for A wins, draw, and B wins using numpy.",
    "description": null,
    "first_lines": "    \"\"\"Calculate total probabilities for A wins, draw, and B wins using numpy.\"\"\"\n    prob_b_wins = np.sum(np.triu(prob_matrix, 1))\n    prob_draw = np.sum(np.diag(prob_matrix))\n    prob_a_wins = np.sum(np.tril(prob_matrix, -1))\n    return prob_a_wins, prob_draw, prob_b_wins",
    "lineno": 72,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def calculate_total_probabilities(prob_matrix):\n    \"\"\"Calculate total probabilities for A wins, draw, and B wins using numpy.\"\"\"\n    prob_b_wins = np.sum(np.triu(prob_matrix, 1))\n    prob_draw = np.sum(np.diag(prob_matrix))\n    prob_a_wins = np.sum(np.tril(prob_matrix, -1))\n    return prob_a_wins, prob_draw, prob_b_wins",
    "documented_params": [],
    "actual_params": [
      "prob_matrix"
    ],
    "missing_params": [
      "prob_matrix"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['prob_matrix']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 71,
    "complexity_score": 65.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "calculate_odds_h2h",
    "path": "",
    "method": "FUNCTION",
    "signature": "prob_a, prob_b, margin, prob_draw=None",
    "docstring": "Convert probabilities to odds.",
    "description": null,
    "first_lines": "    \"\"\"Convert probabilities to odds.\"\"\"\n    if prob_draw is None:\n        a_prob_without_draw = prob_a / (prob_a + prob_b)\n        b_prob_without_draw = prob_b / (prob_b + prob_a)\n",
    "lineno": 80,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def calculate_odds_h2h(prob_a, prob_b, margin, prob_draw=None):\n    \"\"\"Convert probabilities to odds.\"\"\"\n    if prob_draw is None:\n        a_prob_without_draw = prob_a / (prob_a + prob_b)\n        b_prob_without_draw = prob_b / (prob_b + prob_a)\n\n        a_prob_with_margin = a_prob_without_draw * margin\n        b_prob_with_margin = b_prob_without_draw * margin\n\n        odds_a_wins = 1 / a_prob_with_margin\n        odds_b_wins = 1 / b_prob_with_margin\n        return odds_a_wins, odds_b_wins\n    else:\n        a_prob_with_margin = prob_a * margin\n        b_prob_with_margin = prob_b * margin\n        draw_prob_with_margin = prob_draw * margin\n\n        odds_a_wins = 1 / a_prob_with_margin\n        odds_b_wins = 1 / b_prob_with_margin\n        odds_draw = 1 / draw_prob_with_margin\n        return odds_a_wins, odds_b_wins, odds_draw",
    "documented_params": [],
    "actual_params": [
      "prob_a",
      "prob_b",
      "margin",
      "prob_draw"
    ],
    "missing_params": [
      "prob_a",
      "prob_b",
      "margin",
      "prob_draw"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['prob_a', 'prob_b', 'margin', 'prob_draw']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 30,
    "complexity_score": 80.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "fetch_upcoming_matches",
    "path": "",
    "method": "FUNCTION",
    "signature": "api_token: str, url: str, initial_params: Optional[Dict[str, Any]]=None",
    "docstring": null,
    "description": null,
    "first_lines": "    global REQUEST_COUNT\n    params = initial_params.copy() if initial_params else {}\n    page = 1\n    aggregated_results = []\n    while True:",
    "lineno": 103,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "def fetch_upcoming_matches(api_token: str, url: str, initial_params: Optional[Dict[str, Any]] = None) -> List:\n    global REQUEST_COUNT\n    params = initial_params.copy() if initial_params else {}\n    page = 1\n    aggregated_results = []\n    while True:\n        params['page'] = page\n        response = requests.get(url, headers={\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_token}\"\n        }, params=params)\n        REQUEST_COUNT += 1\n\n        if response.status_code == 200:\n            current_page_result = response.json()\n            if not current_page_result:\n                break\n            aggregated_results.extend(current_page_result)\n            page += 1\n        else:\n            raise HTTPException(status_code=response.status_code, detail=f\"Failed to fetch data: {response.text}\")\n\n    return aggregated_results",
    "documented_params": [],
    "actual_params": [
      "api_token",
      "url",
      "initial_params"
    ],
    "missing_params": [
      "api_token",
      "url",
      "initial_params"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "api_token": "str",
      "url": "str",
      "initial_params": "Optional[Dict[str, Any]]"
    },
    "return_type": "List",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['api_token', 'url', 'initial_params']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "upcoming_matches",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'",
    "lineno": 129,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def upcoming_matches():\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'\n    params = {\n        \"filter[future]\": \"true\",\n        \"sort\": \"begin_at\",\n        \"per_page\": 100\n    }\n\n    try:\n        all_upcoming_matches = fetch_upcoming_matches(api_token, url, params)\n\n        return all_upcoming_matches\n    except requests.HTTPError as http_error:\n        status_code = http_error.response.status_code\n        detail = f\"Failed to fetch data from PandaScore API: {http_error}\"\n        raise HTTPException(status_code=status_code, detail=detail)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "upcoming_matches",
    "path": "/fastapi/upcoming-matches",
    "method": "GET",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'",
    "lineno": 129,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def upcoming_matches():\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'\n    params = {\n        \"filter[future]\": \"true\",\n        \"sort\": \"begin_at\",\n        \"per_page\": 100\n    }\n\n    try:\n        all_upcoming_matches = fetch_upcoming_matches(api_token, url, params)\n\n        return all_upcoming_matches\n    except requests.HTTPError as http_error:\n        status_code = http_error.response.status_code\n        detail = f\"Failed to fetch data from PandaScore API: {http_error}\"\n        raise HTTPException(status_code=status_code, detail=detail)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 56.0
  },
  {
    "module": "routers",
    "qualname": "optimized_fetch_and_aggregate",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "team_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()",
    "lineno": 152,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def optimized_fetch_and_aggregate(team_id: int):\n    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()\n\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    teams_url = 'https://api.pandascore.co/csgo/teams'\n\n    params_team = {\n        \"filter[id]\": [team_id]\n    }\n    player_games_params = {\n        \"per_page\": 35\n    }\n\n    try:\n        response = requests.get(teams_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                }\n                                , params=params_team)\n        team_data = response.json()\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n    except Exception as e:\n        print(f\"some problem: {e}\")\n\n    for player in team_data[0][\"players\"]:\n        player_id = player[\"id\"]\n        first_name = player.get(\"first_name\", \"\")\n        last_name = player.get(\"last_name\", \"\")\n        nick_name = player.get(\"name\", '')\n        player_details[player_id][\"first_name\"] = first_name\n        player_details[player_id][\"last_name\"] = last_name\n        player_details[player_id][\"name\"] = nick_name\n        player_games_url = f\"https://api.pandascore.co/players/{player_id}/matches?per_page=70&sort=-modified_at\"\n\n        response = requests.get(player_games_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                })\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n\n        player_matches = response.json()\n\n        games_collected = 0\n\n        for match in player_matches:\n            for game in match.get('games', []):\n                if games_collected >= 70:\n                    break\n                game_id = game['id']\n                if game_id not in unique_game_ids:\n                    unique_game_ids.add(game_id)\n                    player_games[player_id].append(game_id)\n                    games_collected += 1\n                    '''\n                    if games_collected >= 70:\n                        break\n                    '''\n\n    total_rounds = 0\n    for game_id in unique_game_ids:\n        player_game_stats_url = f\"https://api.pandascore.co/csgo/games/{game_id}\"\n\n        try:\n            response = requests.get(player_game_stats_url,\n                                    headers={\n                                        \"Accept\": \"application/json\",\n                                        \"Authorization\": f\"Bearer {api_token}\"\n                                    })\n            REQUEST_COUNT += 1\n            print(f\"REQ CONT: {REQUEST_COUNT}\")\n            response.raise_for_status()\n            player_game_stats = response.json()\n            rounds_score = player_game_stats.get(\"rounds_score\", [])\n            game_rounds = sum(int(round_info[\"score\"]) for round_info in rounds_score if \"score\" in round_info)\n            total_rounds += game_rounds\n\n            for player_stat in player_game_stats.get('players', []):\n                pid = player_stat['player']['id']\n                if pid in player_games:\n                    kills = player_stat.get('kills', 0)\n                    headshots = player_stat.get(\"headshots\", 0)\n                    player_details[pid][\"kills\"].append(kills)\n                    player_details[pid][\"headshots\"].append(headshots)\n                    player_details[pid][\"rounds\"].append(game_rounds)\n\n        except requests.RequestException as e:\n            print(f\"Failed to fetch player game stats: {e}\")\n\n    for pid, details in player_details.items():\n        \"\"\"\n        This section calculates the weighted average kills (KPR) and headshot percentage for each player over their \n        last 70 and 30 maps played.\n\n        Segments:\n        - The first segment (`x`) considers the last 70 maps.\n        - The second segment (`y`) considers the last 30 maps.\n\n        Calculations:\n        1. `sum_first_x` represents the average kills per round (KPR) for the last 70 maps, weighted by 0.5.\n        2. `sum_first_y` represents the KPR for the last 30 maps, also weighted by 0.5.\n        3. The `weighted_avg_kills` is the sum of `sum_first_x` and `sum_first_y`\n\n        The KPR is rounded to three decimal places, with equal weights (0.5) for statistics from both the 70-map and \n        30-map segments.\n\n        Additionally, the `headshot_percentage` is calculated as the ratio of total headshots to total kills over the \n        last 70 maps, expressed as a percentage.\n\n        Calculations:\n        - `sum_kills_70`: Total kills over the last 70 maps.\n        - `sum_rounds_70`: Total rounds played over the last 70 maps.\n        - `sum_kills_30`: Total kills over the last 30 maps.\n        - `sum_rounds_30`: Total rounds played over the last 30 maps.\n        - `sum_headshots`: Total headshots over the last 70 maps.\n\n        The `weighted_avg_kills` and `headshot_percentage` are stored in `player_details` for each player\n        \"\"\"\n\n        sum_kills_70 = sum(details[\"kills\"][:70])\n        sum_rounds_70 = sum(details[\"rounds\"][:70])\n        sum_kills_30 = sum(details[\"kills\"][:30])\n        sum_rounds_30 = sum(details[\"rounds\"][:30])\n        sum_headshots = sum(details[\"headshots\"][:70])\n\n        sum_first_x = (sum_kills_70 / sum_rounds_70 * 0.5) if sum_rounds_70 else 0\n        sum_first_y = (sum_kills_30 / sum_rounds_30 * 0.5) if sum_rounds_30 else 0\n        weighted_avg_kills = sum_first_x + sum_first_y\n        player_details[pid][\"weighted_avg_kills\"] = round(weighted_avg_kills, 3)\n\n        headshot_percentage = (sum_headshots / sum_kills_70 * 100) if sum_kills_70 else 0\n        player_details[pid][\"headshots_percentage\"] = round(headshot_percentage, 2)\n\n    players_data = {\"team_id\": team_data[0][\"id\"], \"total_rounds\": total_rounds, \"players\": []}\n    for pid, details in player_details.items():\n        print(details)\n\n        players_data[\"players\"].append({\n            \"player_id\": pid,\n            \"first_name\": details[\"first_name\"],\n            \"last_name\": details[\"last_name\"],\n            \"name\": details[\"name\"],\n            \"player_kills\": sum(details[\"kills\"]),\n            \"player_headshots\": sum(details[\"headshots\"]),\n            \"weighted_avg_kills\": details[\"weighted_avg_kills\"],\n            \"headshots_percentage\": details[\"headshots_percentage\"]\n        })\n    end = time.time()\n    print(f\"It took {end - start} s.\")\n    return players_data",
    "documented_params": [],
    "actual_params": [
      "team_id"
    ],
    "missing_params": [
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "int"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "optimized_fetch_and_aggregate",
    "path": "/team/{team_id}",
    "method": "GET",
    "signature": "team_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()",
    "lineno": 152,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def optimized_fetch_and_aggregate(team_id: int):\n    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()\n\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    teams_url = 'https://api.pandascore.co/csgo/teams'\n\n    params_team = {\n        \"filter[id]\": [team_id]\n    }\n    player_games_params = {\n        \"per_page\": 35\n    }\n\n    try:\n        response = requests.get(teams_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                }\n                                , params=params_team)\n        team_data = response.json()\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n    except Exception as e:\n        print(f\"some problem: {e}\")\n\n    for player in team_data[0][\"players\"]:\n        player_id = player[\"id\"]\n        first_name = player.get(\"first_name\", \"\")\n        last_name = player.get(\"last_name\", \"\")\n        nick_name = player.get(\"name\", '')\n        player_details[player_id][\"first_name\"] = first_name\n        player_details[player_id][\"last_name\"] = last_name\n        player_details[player_id][\"name\"] = nick_name\n        player_games_url = f\"https://api.pandascore.co/players/{player_id}/matches?per_page=70&sort=-modified_at\"\n\n        response = requests.get(player_games_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                })\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n\n        player_matches = response.json()\n\n        games_collected = 0\n\n        for match in player_matches:\n            for game in match.get('games', []):\n                if games_collected >= 70:\n                    break\n                game_id = game['id']\n                if game_id not in unique_game_ids:\n                    unique_game_ids.add(game_id)\n                    player_games[player_id].append(game_id)\n                    games_collected += 1\n                    '''\n                    if games_collected >= 70:\n                        break\n                    '''\n\n    total_rounds = 0\n    for game_id in unique_game_ids:\n        player_game_stats_url = f\"https://api.pandascore.co/csgo/games/{game_id}\"\n\n        try:\n            response = requests.get(player_game_stats_url,\n                                    headers={\n                                        \"Accept\": \"application/json\",\n                                        \"Authorization\": f\"Bearer {api_token}\"\n                                    })\n            REQUEST_COUNT += 1\n            print(f\"REQ CONT: {REQUEST_COUNT}\")\n            response.raise_for_status()\n            player_game_stats = response.json()\n            rounds_score = player_game_stats.get(\"rounds_score\", [])\n            game_rounds = sum(int(round_info[\"score\"]) for round_info in rounds_score if \"score\" in round_info)\n            total_rounds += game_rounds\n\n            for player_stat in player_game_stats.get('players', []):\n                pid = player_stat['player']['id']\n                if pid in player_games:\n                    kills = player_stat.get('kills', 0)\n                    headshots = player_stat.get(\"headshots\", 0)\n                    player_details[pid][\"kills\"].append(kills)\n                    player_details[pid][\"headshots\"].append(headshots)\n                    player_details[pid][\"rounds\"].append(game_rounds)\n\n        except requests.RequestException as e:\n            print(f\"Failed to fetch player game stats: {e}\")\n\n    for pid, details in player_details.items():\n        \"\"\"\n        This section calculates the weighted average kills (KPR) and headshot percentage for each player over their \n        last 70 and 30 maps played.\n\n        Segments:\n        - The first segment (`x`) considers the last 70 maps.\n        - The second segment (`y`) considers the last 30 maps.\n\n        Calculations:\n        1. `sum_first_x` represents the average kills per round (KPR) for the last 70 maps, weighted by 0.5.\n        2. `sum_first_y` represents the KPR for the last 30 maps, also weighted by 0.5.\n        3. The `weighted_avg_kills` is the sum of `sum_first_x` and `sum_first_y`\n\n        The KPR is rounded to three decimal places, with equal weights (0.5) for statistics from both the 70-map and \n        30-map segments.\n\n        Additionally, the `headshot_percentage` is calculated as the ratio of total headshots to total kills over the \n        last 70 maps, expressed as a percentage.\n\n        Calculations:\n        - `sum_kills_70`: Total kills over the last 70 maps.\n        - `sum_rounds_70`: Total rounds played over the last 70 maps.\n        - `sum_kills_30`: Total kills over the last 30 maps.\n        - `sum_rounds_30`: Total rounds played over the last 30 maps.\n        - `sum_headshots`: Total headshots over the last 70 maps.\n\n        The `weighted_avg_kills` and `headshot_percentage` are stored in `player_details` for each player\n        \"\"\"\n\n        sum_kills_70 = sum(details[\"kills\"][:70])\n        sum_rounds_70 = sum(details[\"rounds\"][:70])\n        sum_kills_30 = sum(details[\"kills\"][:30])\n        sum_rounds_30 = sum(details[\"rounds\"][:30])\n        sum_headshots = sum(details[\"headshots\"][:70])\n\n        sum_first_x = (sum_kills_70 / sum_rounds_70 * 0.5) if sum_rounds_70 else 0\n        sum_first_y = (sum_kills_30 / sum_rounds_30 * 0.5) if sum_rounds_30 else 0\n        weighted_avg_kills = sum_first_x + sum_first_y\n        player_details[pid][\"weighted_avg_kills\"] = round(weighted_avg_kills, 3)\n\n        headshot_percentage = (sum_headshots / sum_kills_70 * 100) if sum_kills_70 else 0\n        player_details[pid][\"headshots_percentage\"] = round(headshot_percentage, 2)\n\n    players_data = {\"team_id\": team_data[0][\"id\"], \"total_rounds\": total_rounds, \"players\": []}\n    for pid, details in player_details.items():\n        print(details)\n\n        players_data[\"players\"].append({\n            \"player_id\": pid,\n            \"first_name\": details[\"first_name\"],\n            \"last_name\": details[\"last_name\"],\n            \"name\": details[\"name\"],\n            \"player_kills\": sum(details[\"kills\"]),\n            \"player_headshots\": sum(details[\"headshots\"]),\n            \"weighted_avg_kills\": details[\"weighted_avg_kills\"],\n            \"headshots_percentage\": details[\"headshots_percentage\"]\n        })\n    end = time.time()\n    print(f\"It took {end - start} s.\")\n    return players_data",
    "documented_params": [],
    "actual_params": [
      "team_id"
    ],
    "missing_params": [
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "int"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "routers",
    "qualname": "predict_stats",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    players_data = data.get(\"players\", [])\n    teams_data = data.get(\"teams\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))",
    "lineno": 312,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def predict_stats(request: Request):\n    data = await request.json()\n    players_data = data.get(\"players\", [])\n    teams_data = data.get(\"teams\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2\n    predicted_kills_team2_map1 = float(data.get(\"predicted_kills_team2_map1\", 0)) / 2\n    predicted_kills_team1_map2 = float(data.get(\"predicted_kills_team1_map2\", 0)) / 2\n    predicted_kills_team2_map2 = float(data.get(\"predicted_kills_team2_map2\", 0)) / 2\n\n    results = []\n    for index, player in enumerate(players_data):\n        if teams_data[0][\"team_id\"] == player[\"team_id\"]:  # Player is in team1\n            team_sum_kills = sum_kills_team1\n            team_predicted_kills_map1 = predicted_kills_team1_map1\n            team_predicted_kills_map2 = predicted_kills_team1_map2\n        elif teams_data[1][\"team_id\"] == player[\"team_id\"]:  # Player is in team2\n            team_sum_kills = sum_kills_team2\n            team_predicted_kills_map1 = predicted_kills_team2_map1\n            team_predicted_kills_map2 = predicted_kills_team2_map2\n\n        proportion = player[\"weighted_avg_kills\"] / team_sum_kills if team_sum_kills > 0 else 0\n\n        predicted_kills_map1 = proportion * team_predicted_kills_map1\n        predicted_kills_map2 = proportion * team_predicted_kills_map2\n\n        total_predicted_kills = predicted_kills_map1 + predicted_kills_map2\n\n        hs_percentage = player[\"headshots_percentage\"] / 100\n        predicted_hs_map1 = predicted_kills_map1 * hs_percentage\n        predicted_hs_map2 = predicted_kills_map2 * hs_percentage\n        total_predicted_hs = total_predicted_kills * hs_percentage\n\n        results.append({\n            \"player_name\": player[\"player_name\"],\n            \"predicted_kills_map1\": round(predicted_kills_map1, 2),\n            \"predicted_hs_map1\": round(predicted_hs_map1, 2),\n            \"predicted_kills_map2\": round(predicted_kills_map2, 2),\n            \"predicted_hs_map2\": round(predicted_hs_map2, 2),\n            \"total_predicted_kills\": round(total_predicted_kills, 2),\n            \"total_predicted_hs\": round(total_predicted_hs, 2),\n        })\n\n    return JSONResponse({\"results\": results})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "predict_stats",
    "path": "/predict-stats",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    players_data = data.get(\"players\", [])\n    teams_data = data.get(\"teams\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))",
    "lineno": 312,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def predict_stats(request: Request):\n    data = await request.json()\n    players_data = data.get(\"players\", [])\n    teams_data = data.get(\"teams\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2\n    predicted_kills_team2_map1 = float(data.get(\"predicted_kills_team2_map1\", 0)) / 2\n    predicted_kills_team1_map2 = float(data.get(\"predicted_kills_team1_map2\", 0)) / 2\n    predicted_kills_team2_map2 = float(data.get(\"predicted_kills_team2_map2\", 0)) / 2\n\n    results = []\n    for index, player in enumerate(players_data):\n        if teams_data[0][\"team_id\"] == player[\"team_id\"]:  # Player is in team1\n            team_sum_kills = sum_kills_team1\n            team_predicted_kills_map1 = predicted_kills_team1_map1\n            team_predicted_kills_map2 = predicted_kills_team1_map2\n        elif teams_data[1][\"team_id\"] == player[\"team_id\"]:  # Player is in team2\n            team_sum_kills = sum_kills_team2\n            team_predicted_kills_map1 = predicted_kills_team2_map1\n            team_predicted_kills_map2 = predicted_kills_team2_map2\n\n        proportion = player[\"weighted_avg_kills\"] / team_sum_kills if team_sum_kills > 0 else 0\n\n        predicted_kills_map1 = proportion * team_predicted_kills_map1\n        predicted_kills_map2 = proportion * team_predicted_kills_map2\n\n        total_predicted_kills = predicted_kills_map1 + predicted_kills_map2\n\n        hs_percentage = player[\"headshots_percentage\"] / 100\n        predicted_hs_map1 = predicted_kills_map1 * hs_percentage\n        predicted_hs_map2 = predicted_kills_map2 * hs_percentage\n        total_predicted_hs = total_predicted_kills * hs_percentage\n\n        results.append({\n            \"player_name\": player[\"player_name\"],\n            \"predicted_kills_map1\": round(predicted_kills_map1, 2),\n            \"predicted_hs_map1\": round(predicted_hs_map1, 2),\n            \"predicted_kills_map2\": round(predicted_kills_map2, 2),\n            \"predicted_hs_map2\": round(predicted_hs_map2, 2),\n            \"total_predicted_kills\": round(total_predicted_kills, 2),\n            \"total_predicted_hs\": round(total_predicted_hs, 2),\n        })\n\n    return JSONResponse({\"results\": results})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "routers",
    "qualname": "generate_h2h_data",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")",
    "lineno": 360,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def generate_h2h_data(request: Request):\n    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")\n\n    player_dict_list = []\n    precomputed_probs = {player: poisson_probabilities(players_data[player][\"sumPredictedKills\"]) for player in\n                         players_data}\n\n    for player1, player2 in combinations(players_data.keys(), 2):\n        prob_matrix = create_probability_matrix(precomputed_probs[player1], precomputed_probs[player2])\n        prob_a_wins, prob_draw, prob_b_wins = calculate_total_probabilities(prob_matrix)\n\n        if data.get('with_draw'):\n            odds_a_wins, odds_b_wins, odds_draw = calculate_odds_h2h(prob_a_wins, prob_b_wins, margin, prob_draw)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)},\n                \"draw\": {\"odds\": round(odds_draw, 2)},\n            })\n        else:\n            odds_a_wins, odds_b_wins = calculate_odds_h2h(prob_a_wins, prob_b_wins, margin)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)}\n            })\n\n    return JSONResponse(content={\"h2h\": player_dict_list})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "generate_h2h_data",
    "path": "/generate-h2h-data",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")",
    "lineno": 360,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def generate_h2h_data(request: Request):\n    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")\n\n    player_dict_list = []\n    precomputed_probs = {player: poisson_probabilities(players_data[player][\"sumPredictedKills\"]) for player in\n                         players_data}\n\n    for player1, player2 in combinations(players_data.keys(), 2):\n        prob_matrix = create_probability_matrix(precomputed_probs[player1], precomputed_probs[player2])\n        prob_a_wins, prob_draw, prob_b_wins = calculate_total_probabilities(prob_matrix)\n\n        if data.get('with_draw'):\n            odds_a_wins, odds_b_wins, odds_draw = calculate_odds_h2h(prob_a_wins, prob_b_wins, margin, prob_draw)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)},\n                \"draw\": {\"odds\": round(odds_draw, 2)},\n            })\n        else:\n            odds_a_wins, odds_b_wins = calculate_odds_h2h(prob_a_wins, prob_b_wins, margin)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)}\n            })\n\n    return JSONResponse(content={\"h2h\": player_dict_list})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "routers",
    "qualname": "generate_over_under_data",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)",
    "lineno": 393,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def generate_over_under_data(request: Request):\n    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)\n\n        odds_data = []\n        for predictedKillsData in data.get(\"predictedKills\", []):\n            player_odds = {}\n            player = predictedKillsData.get(\"player\", {})\n            player_odds[\"player\"] = player\n            player_map1_prediction = predictedKillsData.get(\"map1\", {})\n            predicted_kills_map1 = player_map1_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_1\"] = calculate_odds_kill(predicted_kills_map1, margin)\n            player_map2_prediction = predictedKillsData.get(\"map2\", {})\n            predicted_kills_map2 = player_map2_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_2\"] = calculate_odds_kill(predicted_kills_map2, margin)\n            total_kills = predicted_kills_map1 + predicted_kills_map2\n            player_odds[\"total_kills\"] = calculate_odds_kill(total_kills, margin)\n            odds_data.append(player_odds)\n\n        return JSONResponse(content={\"odds_data\": odds_data, \"margin_error\": margin_error})\n\n    except json.JSONDecodeError:\n        return HTTPException(status_code=400, detail=\"Invalid JSON\")",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "routers",
    "qualname": "generate_over_under_data",
    "path": "/generate-over-under-data",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)",
    "lineno": 393,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/routers.py",
    "full_source": "async def generate_over_under_data(request: Request):\n    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)\n\n        odds_data = []\n        for predictedKillsData in data.get(\"predictedKills\", []):\n            player_odds = {}\n            player = predictedKillsData.get(\"player\", {})\n            player_odds[\"player\"] = player\n            player_map1_prediction = predictedKillsData.get(\"map1\", {})\n            predicted_kills_map1 = player_map1_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_1\"] = calculate_odds_kill(predicted_kills_map1, margin)\n            player_map2_prediction = predictedKillsData.get(\"map2\", {})\n            predicted_kills_map2 = player_map2_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_2\"] = calculate_odds_kill(predicted_kills_map2, margin)\n            total_kills = predicted_kills_map1 + predicted_kills_map2\n            player_odds[\"total_kills\"] = calculate_odds_kill(total_kills, margin)\n            odds_data.append(player_odds)\n\n        return JSONResponse(content={\"odds_data\": odds_data, \"margin_error\": margin_error})\n\n    except json.JSONDecodeError:\n        return HTTPException(status_code=400, detail=\"Invalid JSON\")",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager",
    "path": "",
    "method": "CLASS",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 19,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "class DatabaseManager:\n    def __init__(self, user, password, host, port, db_name):\n        self.database_url = f\"postgresql://{user}:{password}@{host}:{port}/{db_name}\"\n        self.engine = create_engine(self.database_url)\n        self.Session = sessionmaker(bind=self.engine)\n\n    def create_tables(self):\n        Base.metadata.create_all(self.engine)\n\n    def check_all_table_exists(self, required_tables):\n        inspector = inspect(self.engine)\n        insp = reflection.Inspector.from_engine(self.engine)\n        print(\"Tables in the database: \", insp.get_table_names())\n        existing_tables = inspector.get_table_names()\n        missing_tables = set(required_tables) - set(existing_tables)\n        if missing_tables:\n            print(f\"Missing tables: {missing_tables}\")\n            return False\n        return True\n\n    def get_session(self):\n        return self.Session()\n\n    def add(self, instance: Base) -> Base:\n        \"\"\"\n        Save an instance of a model to the database\n        \"\"\"\n        with self.get_session() as session:\n            session.add(instance)\n            session.commit()\n            session.refresh(instance)\n        return instance\n\n    def get(self, model_class, object_id) -> Base:\n        \"\"\"\n        Fetch a single instance of a model by its ID.\n        \"\"\"\n        with self.get_session() as session:\n            try:\n                return session.query(model_class).filter(model_class.id == object_id).one()\n            except NoResultFound:\n                return None\n\n    def get_all(self, model_class) -> list:\n        \"\"\"\n        Fetch all instances of a model\n        \"\"\"\n        with self.get_session() as session:\n            return session.query(model_class).all()\n\n    def update(self, model_class, object_id, **kwargs) -> Base:\n        \"\"\"\n        Update a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            object = session.query(model_class).filter(model_class.id == object_id).one()\n            for key, value in kwargs.items():\n                setattr(object, key, value)\n            session.commit()\n            return object\n\n    def delete(self, model_class, object_id) -> bool:\n        \"\"\"\n        Delete a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            try:\n                object = session.query(model_class).filter(model_class.id == object_id).one()\n                session.delete(object)\n                session.commit()\n                return True\n            except NoResultFound:\n                return False\n\n    def clear_all_data(self):\n        with self.get_session() as session:\n            meta = MetaData()\n            meta.reflect(bind=self.engine)\n            for table in reversed(meta.sorted_tables):\n                session.execute(table.delete())\n            session.commit()\n\n    @contextmanager\n    def get_session(self):\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.__init__",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, user, password, host, port, db_name",
    "docstring": null,
    "description": null,
    "first_lines": "        self.database_url = f\"postgresql://{user}:{password}@{host}:{port}/{db_name}\"\n        self.engine = create_engine(self.database_url)\n        self.Session = sessionmaker(bind=self.engine)",
    "lineno": 20,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def __init__(self, user, password, host, port, db_name):\n        self.database_url = f\"postgresql://{user}:{password}@{host}:{port}/{db_name}\"\n        self.engine = create_engine(self.database_url)\n        self.Session = sessionmaker(bind=self.engine)",
    "documented_params": [],
    "actual_params": [
      "user",
      "password",
      "host",
      "port",
      "db_name"
    ],
    "missing_params": [
      "user",
      "password",
      "host",
      "port",
      "db_name"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['user', 'password', 'host', 'port', 'db_name']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 85.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.create_tables",
    "path": "",
    "method": "FUNCTION",
    "signature": "self",
    "docstring": null,
    "description": null,
    "first_lines": "        Base.metadata.create_all(self.engine)",
    "lineno": 25,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def create_tables(self):\n        Base.metadata.create_all(self.engine)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.check_all_table_exists",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, required_tables",
    "docstring": null,
    "description": null,
    "first_lines": "        inspector = inspect(self.engine)\n        insp = reflection.Inspector.from_engine(self.engine)\n        print(\"Tables in the database: \", insp.get_table_names())\n        existing_tables = inspector.get_table_names()\n        missing_tables = set(required_tables) - set(existing_tables)",
    "lineno": 28,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def check_all_table_exists(self, required_tables):\n        inspector = inspect(self.engine)\n        insp = reflection.Inspector.from_engine(self.engine)\n        print(\"Tables in the database: \", insp.get_table_names())\n        existing_tables = inspector.get_table_names()\n        missing_tables = set(required_tables) - set(existing_tables)\n        if missing_tables:\n            print(f\"Missing tables: {missing_tables}\")\n            return False\n        return True",
    "documented_params": [],
    "actual_params": [
      "required_tables"
    ],
    "missing_params": [
      "required_tables"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['required_tables']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.get_session",
    "path": "",
    "method": "FUNCTION",
    "signature": "self",
    "docstring": null,
    "description": null,
    "first_lines": "        return self.Session()",
    "lineno": 39,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def get_session(self):\n        return self.Session()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.add",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, instance: Base",
    "docstring": "Save an instance of a model to the database",
    "description": null,
    "first_lines": "        \"\"\"\n        Save an instance of a model to the database\n        \"\"\"\n        with self.get_session() as session:\n            session.add(instance)",
    "lineno": 42,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def add(self, instance: Base) -> Base:\n        \"\"\"\n        Save an instance of a model to the database\n        \"\"\"\n        with self.get_session() as session:\n            session.add(instance)\n            session.commit()\n            session.refresh(instance)\n        return instance",
    "documented_params": [],
    "actual_params": [
      "instance"
    ],
    "missing_params": [
      "instance"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "instance": "Base"
    },
    "return_type": "Base",
    "has_type_hints": true,
    "coverage_score": 40.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['instance']",
      "Missing return documentation"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 43,
    "complexity_score": 45.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.get",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, model_class, object_id",
    "docstring": "Fetch a single instance of a model by its ID.",
    "description": null,
    "first_lines": "        \"\"\"\n        Fetch a single instance of a model by its ID.\n        \"\"\"\n        with self.get_session() as session:\n            try:",
    "lineno": 52,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def get(self, model_class, object_id) -> Base:\n        \"\"\"\n        Fetch a single instance of a model by its ID.\n        \"\"\"\n        with self.get_session() as session:\n            try:\n                return session.query(model_class).filter(model_class.id == object_id).one()\n            except NoResultFound:\n                return None",
    "documented_params": [],
    "actual_params": [
      "model_class",
      "object_id"
    ],
    "missing_params": [
      "model_class",
      "object_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "Base",
    "has_type_hints": true,
    "coverage_score": 40.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['model_class', 'object_id']",
      "Missing return documentation"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 45,
    "complexity_score": 50.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.get_all",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, model_class",
    "docstring": "Fetch all instances of a model",
    "description": null,
    "first_lines": "        \"\"\"\n        Fetch all instances of a model\n        \"\"\"\n        with self.get_session() as session:\n            return session.query(model_class).all()",
    "lineno": 62,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def get_all(self, model_class) -> list:\n        \"\"\"\n        Fetch all instances of a model\n        \"\"\"\n        with self.get_session() as session:\n            return session.query(model_class).all()",
    "documented_params": [],
    "actual_params": [
      "model_class"
    ],
    "missing_params": [
      "model_class"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "list",
    "has_type_hints": true,
    "coverage_score": 40.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['model_class']",
      "Missing return documentation"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 30,
    "complexity_score": 45.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.update",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, model_class, object_id, **kwargs",
    "docstring": "Update a single instance of a model by its ID",
    "description": null,
    "first_lines": "        \"\"\"\n        Update a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            object = session.query(model_class).filter(model_class.id == object_id).one()",
    "lineno": 69,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def update(self, model_class, object_id, **kwargs) -> Base:\n        \"\"\"\n        Update a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            object = session.query(model_class).filter(model_class.id == object_id).one()\n            for key, value in kwargs.items():\n                setattr(object, key, value)\n            session.commit()\n            return object",
    "documented_params": [],
    "actual_params": [
      "model_class",
      "object_id",
      "**kwargs"
    ],
    "missing_params": [
      "model_class",
      "object_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "Base",
    "has_type_hints": true,
    "coverage_score": 53.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['model_class', 'object_id']",
      "Missing return documentation"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 45,
    "complexity_score": 55.0,
    "maintainability_score": 60.8,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.delete",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, model_class, object_id",
    "docstring": "Delete a single instance of a model by its ID",
    "description": null,
    "first_lines": "        \"\"\"\n        Delete a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            try:",
    "lineno": 80,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def delete(self, model_class, object_id) -> bool:\n        \"\"\"\n        Delete a single instance of a model by its ID\n        \"\"\"\n        with self.get_session() as session:\n            try:\n                object = session.query(model_class).filter(model_class.id == object_id).one()\n                session.delete(object)\n                session.commit()\n                return True\n            except NoResultFound:\n                return False",
    "documented_params": [],
    "actual_params": [
      "model_class",
      "object_id"
    ],
    "missing_params": [
      "model_class",
      "object_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "bool",
    "has_type_hints": true,
    "coverage_score": 40.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['model_class', 'object_id']",
      "Missing return documentation"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 45,
    "complexity_score": 50.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.clear_all_data",
    "path": "",
    "method": "FUNCTION",
    "signature": "self",
    "docstring": null,
    "description": null,
    "first_lines": "        with self.get_session() as session:\n            meta = MetaData()\n            meta.reflect(bind=self.engine)\n            for table in reversed(meta.sorted_tables):\n                session.execute(table.delete())",
    "lineno": 93,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def clear_all_data(self):\n        with self.get_session() as session:\n            meta = MetaData()\n            meta.reflect(bind=self.engine)\n            for table in reversed(meta.sorted_tables):\n                session.execute(table.delete())\n            session.commit()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "DatabaseManager.get_session",
    "path": "",
    "method": "FUNCTION",
    "signature": "self",
    "docstring": null,
    "description": null,
    "first_lines": "        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:",
    "lineno": 102,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def get_session(self):\n        session = self.Session()\n        try:\n            yield session\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        finally:\n            session.close()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "manager",
    "qualname": "get_db",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    with database_manager.get_session() as db:\n        yield db",
    "lineno": 117,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/manager.py",
    "full_source": "def get_db():\n    with database_manager.get_session() as db:\n        yield db",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "match_result",
    "qualname": "MatchResult",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 8,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/match_result.py",
    "full_source": "class MatchResult(Base):\n    __tablename__ = 'match_results'\n    id = Column(Integer, primary_key=True)\n    match_id = Column(Integer, ForeignKey('matches.match_id'))\n    team1_id = Column(Integer, ForeignKey('teams.team_id'))\n    team2_id = Column(Integer, ForeignKey('teams.team_id'))\n    score_team1 = Column(Integer)\n    score_team2 = Column(Integer)\n\n    match = relationship(\"Match\", back_populates=\"results\")\n    team1 = relationship(\"Team\", foreign_keys=[team1_id])\n    team2 = relationship(\"Team\", foreign_keys=[team2_id])",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "game",
    "qualname": "Game",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/game.py",
    "full_source": "class Game(Base):\n    __tablename__ = \"games\"\n    game_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    match_id = Column(Integer, ForeignKey('matches.match_id'))\n    begin_at = Column(DateTime)\n    complete = Column(Boolean)\n    detailed_stats = Column(Boolean)\n    finished = Column(Boolean)\n    forfeit = Column(Boolean)\n    length = Column(Integer)\n    status = Column(String)\n    winner_team_id = Column(Integer)\n    match = relationship('Match', back_populates=\"games\")\n    player_results = relationship(\"PlayerResult\", back_populates='game', order_by=\"PlayerResult.id\")\n    round_scores = relationship(\"RoundScore\", back_populates='game', order_by=\"RoundScore.id\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "league",
    "qualname": "League",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/league.py",
    "full_source": "class League(Base):\n    __tablename__ = \"leagues\"\n    league_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    image_url = Column(String)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    slug = Column(String)\n    url = Column(String)\n    tournaments = relationship(\"Tournament\", back_populates=\"league\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_stats",
    "qualname": "PlayerStats",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/player_stats.py",
    "full_source": "class PlayerStats(Base):\n    __tablename__ = \"player_stats\"\n    id = Column(Integer, primary_key=True)\n    player_id = Column(Integer, ForeignKey('players.player_id'))\n    player = relationship(\"Player\", back_populates='stats')\n\n    #Counts\n\n    assists = Column(Integer)\n    deaths = Column(Integer)\n    first_kills_diff = Column(Integer)\n    flash_assists = Column(Integer)\n    games_draw = Column(Integer)\n    games_lost = Column(Integer)\n    games_played = Column(Integer)\n    games_won = Column(Integer)\n    headshots = Column(Integer)\n    k_d_diff = Column(Integer)\n    kills = Column(Integer)\n    matches_draw = Column(Integer)\n    matches_lost = Column(Integer)\n    matches_played = Column(Integer)\n    matches_won = Column(Integer)\n    rounds_played = Column(Integer)\n\n    # Per Game Averages\n    adr_per_game = Column(Float)\n    assists_per_game = Column(Float)\n    deaths_per_game = Column(Float)\n    first_kills_diff_per_game = Column(Float)\n    flash_assists_per_game = Column(Float)\n    headshots_per_game = Column(Float)\n    hltv_game_rating = Column(Float)\n    k_d_diff_per_game = Column(Float)\n    kast_per_game = Column(Float)\n    kills_per_game = Column(Float)\n\n    # Per Round Averages\n    assists_per_round = Column(Float)\n    deaths_per_round = Column(Float)\n    first_kills_diff_per_round = Column(Float)\n    flash_assists_per_round = Column(Float)\n    headshots_per_round = Column(Float)\n    k_d_diff_per_round = Column(Float)\n    kills_per_round = Column(Float)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "team",
    "qualname": "Team",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/team.py",
    "full_source": "class Team(Base):\n    __tablename__ = \"teams\"\n    team_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    acronym = Column(String)\n    image_url = Column(String)\n    location = Column(String)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    slug = Column(String)\n    players = relationship(\"Player\", secondary=team_player_link, back_populates=\"teams\")\n    tournaments = relationship(\"Tournament\", secondary=tournament_team_link, back_populates=\"teams\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "stream",
    "qualname": "Stream",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/stream.py",
    "full_source": "class Stream(Base):\n    __tablename__ = \"streams\"\n    id = Column(Integer, primary_key=True)\n    embed_url = Column(String)\n    language = Column(String)\n    main = Column(Boolean)\n    official = Column(Boolean)\n    raw_url = Column(String)\n    match_id = Column(Integer, ForeignKey('matches.match_id'))\n    match = relationship(\"Match\", back_populates=\"streams_list\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player",
    "qualname": "Player",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/player.py",
    "full_source": "class Player(Base):\n    __tablename__ = 'players'\n    player_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    active = Column(Boolean)\n    age = Column(Integer)\n    birthday = Column(DateTime)\n    first_name = Column(String)\n    image_url = Column(String)\n    last_name = Column(String)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    nationality = Column(String)\n    role = Column(String)\n    slug = Column(String)\n    teams = relationship(\"Team\", secondary='team_player_link', back_populates='players')\n    stats = relationship(\"PlayerStats\", back_populates='player', uselist=False)\n    results = relationship(\"PlayerResult\", back_populates='player')",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "serie",
    "qualname": "Serie",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/serie.py",
    "full_source": "class Serie(Base):\n    __tablename__ = \"series\"\n    serie_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    begin_at = Column(DateTime)\n    end_at = Column(DateTime)\n    full_name = Column(String)\n    league_id = Column(Integer)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    season = Column(String)\n    slug = Column(String)\n    winner_id = Column(Integer)\n    winner_type = Column(String)\n    year = Column(Integer)\n    tournaments = relationship(\"Tournament\", back_populates=\"serie\")",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "round_score",
    "qualname": "RoundScore",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/round_score.py",
    "full_source": "class RoundScore(Base):\n    __tablename__ = \"round_scores\"\n    id = Column(Integer, primary_key=True)\n    game_id = Column(Integer, ForeignKey('games.game_id'), nullable=False)\n    team_id = Column(Integer, ForeignKey('teams.team_id'), nullable=False)\n    score = Column(Integer, nullable=False)\n    game = relationship(\"Game\", back_populates='round_scores')\n    team = relationship('Team')",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_result",
    "qualname": "PlayerResult",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/player_result.py",
    "full_source": "class PlayerResult(Base):\n    __tablename__ = 'player_results'\n    id = Column(Integer, primary_key=True)\n    game_id = Column(Integer, ForeignKey('games.game_id'))\n    player_id = Column(Integer, ForeignKey('players.player_id'))\n    adr = Column(Float)\n    assists = Column(Integer)\n    deaths = Column(Integer)\n    first_kills_diff = Column(Integer)\n    flash_assists = Column(Integer)\n    headshots = Column(Integer)\n    k_d_diff = Column(Integer)\n    kast = Column(Float)\n    kills = Column(Integer)\n    rating = Column(Float)\n    game = relationship(\"Game\", back_populates='player_results')\n    player = relationship(\"Player\", back_populates='results')",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "tournament",
    "qualname": "Tournament",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 9,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/tournament.py",
    "full_source": "class Tournament(Base):\n    __tablename__ = \"tournaments\"\n    tournament_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    begin_at = Column(DateTime)\n    detailed_stats = Column(Boolean)\n    end_at = Column(DateTime)\n    has_bracket = Column(Boolean)\n    league_id = Column(Integer, ForeignKey(\"leagues.league_id\"))\n    live_supported = Column(Boolean)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    prizepool = Column(String)\n    serie_id = Column(Integer, ForeignKey(\"series.serie_id\"))\n    slug = Column(String)\n    tier = Column(String)\n    videogame = Column(JSONB)\n    videogame_title = Column(JSONB)\n    winner_id = Column(Integer)\n    winner_type = Column(String)\n    league = relationship(\"League\", back_populates=\"tournaments\")\n    serie = relationship(\"Serie\", back_populates=\"tournaments\")\n    matches = relationship(\"Match\", back_populates=\"tournament\")\n    teams = relationship(\"Team\", secondary=tournament_team_link)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "match",
    "qualname": "Match",
    "path": "",
    "method": "CLASS",
    "signature": "inherits=(Base)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 8,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/database/models/match.py",
    "full_source": "class Match(Base):\n    __tablename__ = \"matches\"\n    tournament_id = Column(Integer, ForeignKey('tournaments.tournament_id'))\n    match_id = Column(Integer, unique=True, nullable=False, index=True, primary_key=True)\n    begin_at = Column(DateTime)\n    detailed_stats = Column(Boolean)\n    draw = Column(Boolean)\n    end_at = Column(DateTime)\n    forfeit = Column(Boolean)\n    game_advantage = Column(String)\n    live = Column(JSONB)\n    match_type = Column(String)\n    modified_at = Column(DateTime)\n    name = Column(String)\n    number_of_games = Column(Integer)\n    original_scheduled_at = Column(DateTime)\n    rescheduled = Column(Boolean)\n    scheduled_at = Column(DateTime)\n    slug = Column(String)\n    status = Column(String)\n    winner_id = Column(Integer)\n    winner_type = Column(String)\n    results = relationship(\"MatchResult\", back_populates='match', uselist=False)\n    tournament = relationship(\"Tournament\", back_populates=\"matches\")\n    streams_list = relationship(\"Stream\", back_populates=\"match\", foreign_keys=\"[Stream.match_id]\")\n    teams = relationship(\"Team\", secondary='match_team_link')\n    games = relationship(\"Game\", back_populates='match')",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing class docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "match_result_base",
    "qualname": "MatchResultBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/match_result_base.py",
    "full_source": "class MatchResultBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    match_id: int\n    team1_id: int\n    team2_id: int\n    score_team1: Optional[int]\n    score_team2: Optional[int]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "match_id": "int",
      "team1_id": "int",
      "team2_id": "int",
      "score_team1": "Optional[int]",
      "score_team2": "Optional[int]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_base",
    "qualname": "PlayerBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_base.py",
    "full_source": "class PlayerBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    active: Optional[bool]\n    age: Optional[int]\n    first_name: Optional[str]\n    birthday: Optional[datetime]\n    player_id: Optional[int]\n    image_url: Optional[HttpUrl]\n    last_name: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    nationality: Optional[str]\n    slug: Optional[str]\n\n    @field_serializer('birthday')\n    def serialize_birthday(self, birthday: Optional[datetime]) -> Optional[str]:\n        if birthday is not None:\n            return birthday.strftime('%Y-%m-%d')\n        return None\n\n    @field_serializer('modified_at')\n    def serialize_modified_at(self, modified_at: Optional[datetime]) -> Optional[str]:\n        if modified_at is not None:\n            return modified_at.isoformat()\n        return None\n\n    @classmethod\n    def from_orm(cls, obj):\n        data = super().from_orm(obj)\n        if isinstance(data.modified_at, datetime):\n            data.modified_at = data.modified_at.isoformat()\n        return data",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "active": "Optional[bool]",
      "age": "Optional[int]",
      "first_name": "Optional[str]",
      "birthday": "Optional[datetime]",
      "player_id": "Optional[int]",
      "image_url": "Optional[HttpUrl]",
      "last_name": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "nationality": "Optional[str]",
      "slug": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_base",
    "qualname": "PlayerBase.serialize_birthday",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, birthday: Optional[datetime]",
    "docstring": null,
    "description": null,
    "first_lines": "        if birthday is not None:\n            return birthday.strftime('%Y-%m-%d')\n        return None",
    "lineno": 22,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_base.py",
    "full_source": "def serialize_birthday(self, birthday: Optional[datetime]) -> Optional[str]:\n        if birthday is not None:\n            return birthday.strftime('%Y-%m-%d')\n        return None",
    "documented_params": [],
    "actual_params": [
      "birthday"
    ],
    "missing_params": [
      "birthday"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "birthday": "Optional[datetime]"
    },
    "return_type": "Optional[str]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['birthday']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_base",
    "qualname": "PlayerBase.serialize_modified_at",
    "path": "",
    "method": "FUNCTION",
    "signature": "self, modified_at: Optional[datetime]",
    "docstring": null,
    "description": null,
    "first_lines": "        if modified_at is not None:\n            return modified_at.isoformat()\n        return None",
    "lineno": 28,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_base.py",
    "full_source": "def serialize_modified_at(self, modified_at: Optional[datetime]) -> Optional[str]:\n        if modified_at is not None:\n            return modified_at.isoformat()\n        return None",
    "documented_params": [],
    "actual_params": [
      "modified_at"
    ],
    "missing_params": [
      "modified_at"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "modified_at": "Optional[datetime]"
    },
    "return_type": "Optional[str]",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['modified_at']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_base",
    "qualname": "PlayerBase.from_orm",
    "path": "",
    "method": "CLASSMETHOD",
    "signature": "cls, obj",
    "docstring": null,
    "description": null,
    "first_lines": "        data = super().from_orm(obj)\n        if isinstance(data.modified_at, datetime):\n            data.modified_at = data.modified_at.isoformat()\n        return data",
    "lineno": 34,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_base.py",
    "full_source": "def from_orm(cls, obj):\n        data = super().from_orm(obj)\n        if isinstance(data.modified_at, datetime):\n            data.modified_at = data.modified_at.isoformat()\n        return data",
    "documented_params": [],
    "actual_params": [
      "cls",
      "obj"
    ],
    "missing_params": [
      "cls",
      "obj"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['cls', 'obj']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 70.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "stream_base",
    "qualname": "StreamBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/stream_base.py",
    "full_source": "class StreamBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    embed_url: Optional[HttpUrl]\n    language: Optional[str]\n    main: bool\n    official: bool\n    raw_url: Optional[HttpUrl]\n    match_id: int",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "embed_url": "Optional[HttpUrl]",
      "language": "Optional[str]",
      "main": "bool",
      "official": "bool",
      "raw_url": "Optional[HttpUrl]",
      "match_id": "int"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "round_score_base",
    "qualname": "RoundScoreBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/round_score_base.py",
    "full_source": "class RoundScoreBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    game_id: int\n    team_id: int\n    score: int",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "game_id": "int",
      "team_id": "int",
      "score": "int"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_result_base",
    "qualname": "PlayerResultBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_result_base.py",
    "full_source": "class PlayerResultBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    game_id: int\n    player_id: int\n    adr: Optional[float]\n    assists: Optional[int]\n    deaths: Optional[int]\n    first_kills_diff: Optional[int]\n    flash_assists: Optional[int]\n    headshots: Optional[int]\n    k_d_diff: Optional[int]\n    kast: Optional[float]\n    kills: Optional[int]\n    rating: Optional[float]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "game_id": "int",
      "player_id": "int",
      "adr": "Optional[float]",
      "assists": "Optional[int]",
      "deaths": "Optional[int]",
      "first_kills_diff": "Optional[int]",
      "flash_assists": "Optional[int]",
      "headshots": "Optional[int]",
      "k_d_diff": "Optional[int]",
      "kast": "Optional[float]",
      "kills": "Optional[int]",
      "rating": "Optional[float]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "match_base",
    "qualname": "MatchBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/match_base.py",
    "full_source": "class MatchBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    begin_at: Optional[datetime]\n    detailed_stats: Optional[bool]\n    draw: Optional[bool]\n    end_at: Optional[datetime]\n    forfeit: Optional[bool]\n    game_advantage: Optional[str]\n    match_id: int\n    live: Optional[dict]\n    match_type: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    number_of_games: Optional[int]\n    original_scheduled_at: Optional[datetime]\n    rescheduled: Optional[bool]\n    scheduled_at: Optional[datetime]\n    slug: Optional[str]\n    status: Optional[str]\n    tournament_id: int\n    winner_id: Optional[int]\n    winner_type: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "begin_at": "Optional[datetime]",
      "detailed_stats": "Optional[bool]",
      "draw": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "forfeit": "Optional[bool]",
      "game_advantage": "Optional[str]",
      "match_id": "int",
      "live": "Optional[dict]",
      "match_type": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "number_of_games": "Optional[int]",
      "original_scheduled_at": "Optional[datetime]",
      "rescheduled": "Optional[bool]",
      "scheduled_at": "Optional[datetime]",
      "slug": "Optional[str]",
      "status": "Optional[str]",
      "tournament_id": "int",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "league_base",
    "qualname": "LeagueBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/league_base.py",
    "full_source": "class LeagueBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    league_id: int\n    image_url: Optional[HttpUrl]\n    modified_at: datetime\n    name: str\n    slug: str\n    url: Optional[HttpUrl]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "league_id": "int",
      "image_url": "Optional[HttpUrl]",
      "modified_at": "datetime",
      "name": "str",
      "slug": "str",
      "url": "Optional[HttpUrl]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "team_base",
    "qualname": "TeamBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/team_base.py",
    "full_source": "class TeamBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    team_id: int = Field(..., alias='id')\n    acronym: Optional[str]\n    image_url: Optional[HttpUrl]\n    location: Optional[str]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    slug: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "team_id": "int",
      "acronym": "Optional[str]",
      "image_url": "Optional[HttpUrl]",
      "location": "Optional[str]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "slug": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "game_base",
    "qualname": "GameBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/game_base.py",
    "full_source": "class GameBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    game_id: int\n    match_id: Optional[int] = Field(None, alias='match_id')\n    begin_at: Optional[datetime]\n    complete: Optional[bool]\n    detailed_stats: Optional[bool]\n    end_at: Optional[datetime]\n    forfeit: Optional[bool]\n    length: Optional[int]\n    position: Optional[int]\n    status: Optional[str]\n    winner_id: Optional[int]\n    winner_type: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "game_id": "int",
      "match_id": "Optional[int]",
      "begin_at": "Optional[datetime]",
      "complete": "Optional[bool]",
      "detailed_stats": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "forfeit": "Optional[bool]",
      "length": "Optional[int]",
      "position": "Optional[int]",
      "status": "Optional[str]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "tournament_base",
    "qualname": "TournamentBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 9,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/tournament_base.py",
    "full_source": "class TournamentBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    tournament_id: int = Field(..., alias='id')\n    begin_at: Optional[datetime]\n    detailed_stats: Optional[bool]\n    end_at: Optional[datetime]\n    has_bracket: Optional[bool]\n    league_id: Optional[int]\n    live_supported: Optional[bool]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    prizepool: Optional[str]\n    serie_id: Optional[int]\n    slug: Optional[str]\n    tier: Optional[str]\n    videogame: Optional[dict]\n    videogame_title: Optional[dict]\n    winner_id: Optional[int]\n    winner_type: Optional[str]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "tournament_id": "int",
      "begin_at": "Optional[datetime]",
      "detailed_stats": "Optional[bool]",
      "end_at": "Optional[datetime]",
      "has_bracket": "Optional[bool]",
      "league_id": "Optional[int]",
      "live_supported": "Optional[bool]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "prizepool": "Optional[str]",
      "serie_id": "Optional[int]",
      "slug": "Optional[str]",
      "tier": "Optional[str]",
      "videogame": "Optional[dict]",
      "videogame_title": "Optional[dict]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "player_stats_base",
    "qualname": "PlayerStatsBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/player_stats_base.py",
    "full_source": "class PlayerStatsBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    player_id: int\n\n    # Counts\n    assists: Optional[int]\n    deaths: Optional[int]\n    first_kills_diff: Optional[int]\n    flash_assists: Optional[int]\n    games_draw: Optional[int]\n    games_lost: Optional[int]\n    games_played: Optional[int]\n    games_won: Optional[int]\n    headshots: Optional[int]\n    k_d_diff: Optional[int]\n    kills: Optional[int]\n    matches_draw: Optional[int]\n    matches_lost: Optional[int]\n    matches_played: Optional[int]\n    matches_won: Optional[int]\n    rounds_played: Optional[int]\n\n    # Per Game Averages\n    adr_per_game: Optional[float]\n    assists_per_game: Optional[float]\n    deaths_per_game: Optional[float]\n    first_kills_diff_per_game: Optional[float]\n    flash_assists_per_game: Optional[float]\n    headshots_per_game: Optional[float]\n    hltv_game_rating: Optional[float]\n    k_d_diff_per_game: Optional[float]\n    kast_per_game: Optional[float]\n    kills_per_game: Optional[float]\n\n    # Per Round Averages\n    assists_per_round: Optional[float]\n    deaths_per_round: Optional[float]\n    first_kills_diff_per_round: Optional[float]\n    flash_assists_per_round: Optional[float]\n    headshots_per_round: Optional[float]\n    k_d_diff_per_round: Optional[float]\n    kills_per_round: Optional[float]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "id": "int",
      "player_id": "int",
      "assists": "Optional[int]",
      "deaths": "Optional[int]",
      "first_kills_diff": "Optional[int]",
      "flash_assists": "Optional[int]",
      "games_draw": "Optional[int]",
      "games_lost": "Optional[int]",
      "games_played": "Optional[int]",
      "games_won": "Optional[int]",
      "headshots": "Optional[int]",
      "k_d_diff": "Optional[int]",
      "kills": "Optional[int]",
      "matches_draw": "Optional[int]",
      "matches_lost": "Optional[int]",
      "matches_played": "Optional[int]",
      "matches_won": "Optional[int]",
      "rounds_played": "Optional[int]",
      "adr_per_game": "Optional[float]",
      "assists_per_game": "Optional[float]",
      "deaths_per_game": "Optional[float]",
      "first_kills_diff_per_game": "Optional[float]",
      "flash_assists_per_game": "Optional[float]",
      "headshots_per_game": "Optional[float]",
      "hltv_game_rating": "Optional[float]",
      "k_d_diff_per_game": "Optional[float]",
      "kast_per_game": "Optional[float]",
      "kills_per_game": "Optional[float]",
      "assists_per_round": "Optional[float]",
      "deaths_per_round": "Optional[float]",
      "first_kills_diff_per_round": "Optional[float]",
      "flash_assists_per_round": "Optional[float]",
      "headshots_per_round": "Optional[float]",
      "k_d_diff_per_round": "Optional[float]",
      "kills_per_round": "Optional[float]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "serie_base",
    "qualname": "SerieBase",
    "path": "",
    "method": "PYDANTIC_MODEL",
    "signature": "inherits=(BaseModel)",
    "docstring": null,
    "description": null,
    "first_lines": "",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/schemas/serie_base.py",
    "full_source": "class SerieBase(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    begin_at: Optional[datetime]\n    end_at: Optional[datetime]\n    full_name: Optional[str]\n    serie_id: int\n    league_id: Optional[int]\n    modified_at: Optional[datetime]\n    name: Optional[str]\n    season: Optional[str]\n    slug: Optional[str]\n    winner_id: Optional[int]\n    winner_type: Optional[str]\n    year: Optional[int]",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "model_config": "Any",
      "begin_at": "Optional[datetime]",
      "end_at": "Optional[datetime]",
      "full_name": "Optional[str]",
      "serie_id": "int",
      "league_id": "Optional[int]",
      "modified_at": "Optional[datetime]",
      "name": "Optional[str]",
      "season": "Optional[str]",
      "slug": "Optional[str]",
      "winner_id": "Optional[int]",
      "winner_type": "Optional[str]",
      "year": "Optional[int]"
    },
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing model docstring"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "funkcja",
    "qualname": "pp",
    "path": "",
    "method": "FUNCTION",
    "signature": "srednia, k",
    "docstring": null,
    "description": null,
    "first_lines": "    return (srednia ** k / (factorial(k))) * exp(-srednia)",
    "lineno": 6,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/temporary/funkcja.py",
    "full_source": "def pp(srednia, k):\n    return (srednia ** k / (factorial(k))) * exp(-srednia)",
    "documented_params": [],
    "actual_params": [
      "srednia",
      "k"
    ],
    "missing_params": [
      "srednia",
      "k"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['srednia', 'k']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 70.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "funkcja",
    "qualname": "dp",
    "path": "",
    "method": "FUNCTION",
    "signature": "srednia, k",
    "docstring": null,
    "description": null,
    "first_lines": "    p = 0\n    for m in range(k + 1, k + 30):\n        p = p + pp(srednia, m)\n    return p",
    "lineno": 10,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/temporary/funkcja.py",
    "full_source": "def dp(srednia, k):\n    p = 0\n    for m in range(k + 1, k + 30):\n        p = p + pp(srednia, m)\n    return p",
    "documented_params": [],
    "actual_params": [
      "srednia",
      "k"
    ],
    "missing_params": [
      "srednia",
      "k"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['srednia', 'k']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 70.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "funkcja",
    "qualname": "wynik",
    "path": "",
    "method": "FUNCTION",
    "signature": "srednie",
    "docstring": null,
    "description": null,
    "first_lines": "    zaw = list(srednie.keys())\n    s = 0\n    for z in zaw:\n        s = s + srednie[z]\n    p = {}",
    "lineno": 17,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/temporary/funkcja.py",
    "full_source": "def wynik(srednie):\n    zaw = list(srednie.keys())\n    s = 0\n    for z in zaw:\n        s = s + srednie[z]\n    p = {}\n    for z in zaw:\n        p[z] = 0\n\n    for z in zaw:\n        for k in range(0, 60):\n            pkz = pp(srednie[z], k)\n            pr = 1\n            for przec in zaw:\n                if przec != z:\n                    px = (1 - dp(srednie[przec], k))\n                    pr = pr * px\n            p[z] = p[z] + pr * pkz\n\n    t = {}\n    for z in zaw:\n        t[z] = round(1 / (p[z] * 1.25), 2)\n\n    sm = 0\n    for z in zaw:\n        sm = sm + p[z]\n    for z in zaw:\n        p[z] = round(p[z] / sm, 2)\n\n    return p, t",
    "documented_params": [],
    "actual_params": [
      "srednie"
    ],
    "missing_params": [
      "srednie"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['srednie']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "tournaments",
    "qualname": "roster_url",
    "path": "",
    "method": "FUNCTION",
    "signature": "tournament_id",
    "docstring": null,
    "description": null,
    "first_lines": "    return f\"https://api.pandascore.co/tournaments/{tournament_id}/rosters\"",
    "lineno": 7,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/temporary/tournaments.py",
    "full_source": "def roster_url(tournament_id):\n    return f\"https://api.pandascore.co/tournaments/{tournament_id}/rosters\"",
    "documented_params": [],
    "actual_params": [
      "tournament_id"
    ],
    "missing_params": [
      "tournament_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['tournament_id']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "roboczy",
    "qualname": "fetch_matches",
    "path": "",
    "method": "FUNCTION",
    "signature": "api_token, url, params=None",
    "docstring": null,
    "description": null,
    "first_lines": "    global REQUEST_COUNT\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Authorization\": f\"Bearer {api_token}\"\n    }",
    "lineno": 10,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/temporary/roboczy.py",
    "full_source": "def fetch_matches(api_token, url, params=None):\n    global REQUEST_COUNT\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Authorization\": f\"Bearer {api_token}\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, params=params)\n        REQUEST_COUNT += 1\n        response.raise_for_status()\n        return response.json()\n    except requests.RequestException as e:\n        print(f\"Failed to fetch data: error {e}\")\n        return None",
    "documented_params": [],
    "actual_params": [
      "api_token",
      "url",
      "params"
    ],
    "missing_params": [
      "api_token",
      "url",
      "params"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['api_token', 'url', 'params']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 75.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "initialize_api",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    app = FastAPI(\n        root_path=\"/api/v1\"\n    )\n\n    app.add_middleware(",
    "lineno": 10,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/main.py",
    "full_source": "def initialize_api():\n    app = FastAPI(\n        root_path=\"/api/v1\"\n    )\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=origins,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    app.include_router(cs2_router)\n\n    return app",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "app",
    "path": "",
    "method": "METADATA",
    "signature": "root_path",
    "docstring": "/api/v1",
    "description": null,
    "first_lines": "",
    "lineno": 11,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "app.middleware",
    "path": "",
    "method": "MIDDLEWARE",
    "signature": "CORSMiddleware",
    "docstring": null,
    "description": "Middleware: CORSMiddleware",
    "first_lines": "",
    "lineno": 15,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "main",
    "qualname": "app.router_inclusion",
    "path": "",
    "method": "ROUTER_INCLUSION",
    "signature": "cs2_router",
    "docstring": null,
    "description": "Router inclusion: cs2_router",
    "first_lines": "",
    "lineno": 23,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/main.py",
    "full_source": "",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 0.0,
    "quality_score": 0.0,
    "completeness_issues": [],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 0.0,
    "maintainability_score": 0.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "get_margin",
    "path": "",
    "method": "FUNCTION",
    "signature": "data",
    "docstring": null,
    "description": null,
    "first_lines": "    margin_str = data.get(\"margin\", None)\n    margin_error = None\n\n    if margin_str is None:\n        margin_error = \"Margin value is missing.\"",
    "lineno": 22,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def get_margin(data):\n    margin_str = data.get(\"margin\", None)\n    margin_error = None\n\n    if margin_str is None:\n        margin_error = \"Margin value is missing.\"\n        return 0.0, margin_error\n    else:\n        try:\n            margin = float(margin_str)\n            return margin, ''\n        except ValueError:\n            margin_error = \"Margin value must be a float.\"\n            return 0.0, margin_error",
    "documented_params": [],
    "actual_params": [
      "data"
    ],
    "missing_params": [
      "data"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 20.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['data']",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 65.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "calculate_odds",
    "path": "",
    "method": "FUNCTION",
    "signature": "kills: float, margin: float",
    "docstring": null,
    "description": null,
    "first_lines": "    absolute_kills_value = int(kills)\n    threshold_kills = absolute_kills_value + 0.5\n    poisson_distribution = poisson.cdf(absolute_kills_value, kills)\n    survival_probability = 1 - poisson_distribution\n    odds1 = 1 / (",
    "lineno": 38,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def calculate_odds(kills: float, margin: float):\n    absolute_kills_value = int(kills)\n    threshold_kills = absolute_kills_value + 0.5\n    poisson_distribution = poisson.cdf(absolute_kills_value, kills)\n    survival_probability = 1 - poisson_distribution\n    odds1 = 1 / (\n            poisson_distribution\n            / (poisson_distribution + survival_probability)\n            * margin\n    )\n    odds2 = 1 / (\n            survival_probability\n            / (poisson_distribution + survival_probability)\n            * margin\n    )\n\n    return {\n        \"line\": threshold_kills,\n        \"odd1\": round(odds1, 2),\n        \"odd2\": round(odds2, 2),\n    }",
    "documented_params": [],
    "actual_params": [
      "kills",
      "margin"
    ],
    "missing_params": [
      "kills",
      "margin"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "kills": "float",
      "margin": "float"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['kills', 'margin']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 50.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "poisson_probabilities",
    "path": "",
    "method": "FUNCTION",
    "signature": "lam",
    "docstring": "Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.",
    "description": null,
    "first_lines": "    \"\"\"Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.\"\"\"\n    return poisson.pmf(np.arange(MAX_KILLS + 1), lam)",
    "lineno": 61,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def poisson_probabilities(lam):\n    \"\"\"Pre-compute Poisson probabilities for the range of kills using numpy for efficiency.\"\"\"\n    return poisson.pmf(np.arange(MAX_KILLS + 1), lam)",
    "documented_params": [],
    "actual_params": [
      "lam"
    ],
    "missing_params": [
      "lam"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['lam']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 84,
    "complexity_score": 65.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "create_probability_matrix",
    "path": "",
    "method": "FUNCTION",
    "signature": "player_a_probs, player_b_probs",
    "docstring": "Use numpy to efficiently create a probability matrix for two players.",
    "description": null,
    "first_lines": "    \"\"\"Use numpy to efficiently create a probability matrix for two players.\"\"\"\n    return np.outer(player_a_probs, player_b_probs)",
    "lineno": 66,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def create_probability_matrix(player_a_probs, player_b_probs):\n    \"\"\"Use numpy to efficiently create a probability matrix for two players.\"\"\"\n    return np.outer(player_a_probs, player_b_probs)",
    "documented_params": [],
    "actual_params": [
      "player_a_probs",
      "player_b_probs"
    ],
    "missing_params": [
      "player_a_probs",
      "player_b_probs"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['player_a_probs', 'player_b_probs']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 69,
    "complexity_score": 70.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "calculate_total_probabilities",
    "path": "",
    "method": "FUNCTION",
    "signature": "prob_matrix",
    "docstring": "Calculate total probabilities for A wins, draw, and B wins using numpy.",
    "description": null,
    "first_lines": "    \"\"\"Calculate total probabilities for A wins, draw, and B wins using numpy.\"\"\"\n    prob_b_wins = np.sum(np.triu(prob_matrix, 1))\n    prob_draw = np.sum(np.diag(prob_matrix))\n    prob_a_wins = np.sum(np.tril(prob_matrix, -1))\n    return prob_a_wins, prob_draw, prob_b_wins",
    "lineno": 71,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def calculate_total_probabilities(prob_matrix):\n    \"\"\"Calculate total probabilities for A wins, draw, and B wins using numpy.\"\"\"\n    prob_b_wins = np.sum(np.triu(prob_matrix, 1))\n    prob_draw = np.sum(np.diag(prob_matrix))\n    prob_a_wins = np.sum(np.tril(prob_matrix, -1))\n    return prob_a_wins, prob_draw, prob_b_wins",
    "documented_params": [],
    "actual_params": [
      "prob_matrix"
    ],
    "missing_params": [
      "prob_matrix"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 30.0,
    "completeness_issues": [
      "Missing parameter docs: ['prob_matrix']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 71,
    "complexity_score": 65.0,
    "maintainability_score": 57.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "calculate_odds",
    "path": "",
    "method": "FUNCTION",
    "signature": "prob_a, prob_b, margin, prob_draw=None",
    "docstring": "Convert probabilities to odds.",
    "description": null,
    "first_lines": "    \"\"\"Convert probabilities to odds.\"\"\"\n    if prob_draw is None:\n        a_prob_without_draw = prob_a / (prob_a + prob_b)\n        b_prob_without_draw = prob_b / (prob_b + prob_a)\n",
    "lineno": 79,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def calculate_odds(prob_a, prob_b, margin, prob_draw=None):\n    \"\"\"Convert probabilities to odds.\"\"\"\n    if prob_draw is None:\n        a_prob_without_draw = prob_a / (prob_a + prob_b)\n        b_prob_without_draw = prob_b / (prob_b + prob_a)\n\n        a_prob_with_margin = a_prob_without_draw * margin\n        b_prob_with_margin = b_prob_without_draw * margin\n\n        odds_a_wins = 1 / a_prob_with_margin\n        odds_b_wins = 1 / b_prob_with_margin\n        return odds_a_wins, odds_b_wins\n    else:\n        a_prob_with_margin = prob_a * margin\n        b_prob_with_margin = prob_b * margin\n        draw_prob_with_margin = prob_draw * margin\n\n        odds_a_wins = 1 / a_prob_with_margin\n        odds_b_wins = 1 / b_prob_with_margin\n        odds_draw = 1 / draw_prob_with_margin\n        return odds_a_wins, odds_b_wins, odds_draw",
    "documented_params": [],
    "actual_params": [
      "prob_a",
      "prob_b",
      "margin",
      "prob_draw"
    ],
    "missing_params": [
      "prob_a",
      "prob_b",
      "margin",
      "prob_draw"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 50.0,
    "quality_score": 15.0,
    "completeness_issues": [
      "Missing parameter docs: ['prob_a', 'prob_b', 'margin', 'prob_draw']",
      "Missing type hints"
    ],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 30,
    "complexity_score": 80.0,
    "maintainability_score": 52.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "fetch_upcoming_matches",
    "path": "",
    "method": "FUNCTION",
    "signature": "api_token: str, url: str, initial_params: Optional[Dict[str, Any]]=None",
    "docstring": null,
    "description": null,
    "first_lines": "    global REQUEST_COUNT\n    params = initial_params.copy() if initial_params else {}\n    page = 1\n    aggregated_results = []\n    while True:",
    "lineno": 102,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "def fetch_upcoming_matches(api_token: str, url: str, initial_params: Optional[Dict[str, Any]] = None) -> List:\n    global REQUEST_COUNT\n    params = initial_params.copy() if initial_params else {}\n    page = 1\n    aggregated_results = []\n    while True:\n        params['page'] = page\n        response = requests.get(url, headers={\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_token}\"\n        }, params=params)\n        REQUEST_COUNT += 1\n\n        if response.status_code == 200:\n            current_page_result = response.json()\n            if not current_page_result:\n                break\n            aggregated_results.extend(current_page_result)\n            page += 1\n        else:\n            raise HTTPException(status_code=response.status_code, detail=f\"Failed to fetch data: {response.text}\")\n\n    return aggregated_results",
    "documented_params": [],
    "actual_params": [
      "api_token",
      "url",
      "initial_params"
    ],
    "missing_params": [
      "api_token",
      "url",
      "initial_params"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "api_token": "str",
      "url": "str",
      "initial_params": "Optional[Dict[str, Any]]"
    },
    "return_type": "List",
    "has_type_hints": true,
    "coverage_score": 10.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['api_token', 'url', 'initial_params']",
      "Missing return documentation"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 55.0,
    "maintainability_score": 42.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "upcoming_matches",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'",
    "lineno": 128,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def upcoming_matches():\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'\n    params = {\n        \"filter[future]\": \"true\",\n        \"sort\": \"begin_at\",\n        \"per_page\": 100\n    }\n\n    try:\n        all_upcoming_matches = fetch_upcoming_matches(api_token, url, params)\n\n        return all_upcoming_matches\n    except requests.HTTPError as http_error:\n        status_code = http_error.response.status_code\n        detail = f\"Failed to fetch data from PandaScore API: {http_error}\"\n        raise HTTPException(status_code=status_code, detail=detail)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "upcoming_matches",
    "path": "/fastapi/upcoming-matches",
    "method": "GET",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'",
    "lineno": 128,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def upcoming_matches():\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    if not api_token:\n        raise HTTPException(status_code=500, detail=\"API token is missing\")\n\n    url = 'https://api.pandascore.co/csgo/matches/upcoming'\n    params = {\n        \"filter[future]\": \"true\",\n        \"sort\": \"begin_at\",\n        \"per_page\": 100\n    }\n\n    try:\n        all_upcoming_matches = fetch_upcoming_matches(api_token, url, params)\n\n        return all_upcoming_matches\n    except requests.HTTPError as http_error:\n        status_code = http_error.response.status_code\n        detail = f\"Failed to fetch data from PandaScore API: {http_error}\"\n        raise HTTPException(status_code=status_code, detail=detail)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 56.0
  },
  {
    "module": "router",
    "qualname": "optimized_fetch_and_aggregate",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "team_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()",
    "lineno": 151,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def optimized_fetch_and_aggregate(team_id: int):\n    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()\n\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    teams_url = 'https://api.pandascore.co/csgo/teams'\n\n    params_team = {\n        \"filter[id]\": [team_id]\n    }\n    player_games_params = {\n        \"per_page\": 35\n    }\n\n    try:\n        response = requests.get(teams_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                }\n                                , params=params_team)\n        team_data = response.json()\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n    except Exception as e:\n        print(f\"some problem: {e}\")\n\n    for player in team_data[0][\"players\"]:\n        player_id = player[\"id\"]\n        first_name = player.get(\"first_name\", \"\")\n        last_name = player.get(\"last_name\", \"\")\n        nick_name = player.get(\"name\", '')\n        player_details[player_id][\"first_name\"] = first_name\n        player_details[player_id][\"last_name\"] = last_name\n        player_details[player_id][\"name\"] = nick_name\n        player_games_url = f\"https://api.pandascore.co/players/{player_id}/matches?per_page=70&sort=-modified_at\"\n\n        response = requests.get(player_games_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                })\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n\n        player_matches = response.json()\n\n        games_collected = 0\n\n        for match in player_matches:\n            for game in match.get('games', []):\n                if games_collected >= 70:\n                    break\n                game_id = game['id']\n                if game_id not in unique_game_ids:\n                    unique_game_ids.add(game_id)\n                    player_games[player_id].append(game_id)\n                    games_collected += 1\n                    '''\n                    if games_collected >= 70:\n                        break\n                    '''\n\n    total_rounds = 0\n    for game_id in unique_game_ids:\n        player_game_stats_url = f\"https://api.pandascore.co/csgo/games/{game_id}\"\n\n        try:\n            response = requests.get(player_game_stats_url,\n                                    headers={\n                                        \"Accept\": \"application/json\",\n                                        \"Authorization\": f\"Bearer {api_token}\"\n                                    })\n            REQUEST_COUNT += 1\n            print(f\"REQ CONT: {REQUEST_COUNT}\")\n            response.raise_for_status()\n            player_game_stats = response.json()\n            rounds_score = player_game_stats.get(\"rounds_score\", [])\n            game_rounds = sum(int(round_info[\"score\"]) for round_info in rounds_score if \"score\" in round_info)\n            total_rounds += game_rounds\n\n            for player_stat in player_game_stats.get('players', []):\n                pid = player_stat['player']['id']\n                if pid in player_games:\n                    kills = player_stat.get('kills', 0)\n                    headshots = player_stat.get(\"headshots\", 0)\n                    player_details[pid][\"kills\"].append(kills)\n                    player_details[pid][\"headshots\"].append(headshots)\n                    player_details[pid][\"rounds\"].append(game_rounds)\n\n        except requests.RequestException as e:\n            print(f\"Failed to fetch player game stats: {e}\")\n\n    for pid, details in player_details.items():\n        \"\"\"\n        This section calculates the weighted average kills (KPR) and headshot percentage for each player over their \n        last 70 and 30 maps played.\n\n        Segments:\n        - The first segment (`x`) considers the last 70 maps.\n        - The second segment (`y`) considers the last 30 maps.\n\n        Calculations:\n        1. `sum_first_x` represents the average kills per round (KPR) for the last 70 maps, weighted by 0.5.\n        2. `sum_first_y` represents the KPR for the last 30 maps, also weighted by 0.5.\n        3. The `weighted_avg_kills` is the sum of `sum_first_x` and `sum_first_y`\n\n        The KPR is rounded to three decimal places, with equal weights (0.5) for statistics from both the 70-map and \n        30-map segments.\n\n        Additionally, the `headshot_percentage` is calculated as the ratio of total headshots to total kills over the \n        last 70 maps, expressed as a percentage.\n\n        Calculations:\n        - `sum_kills_70`: Total kills over the last 70 maps.\n        - `sum_rounds_70`: Total rounds played over the last 70 maps.\n        - `sum_kills_30`: Total kills over the last 30 maps.\n        - `sum_rounds_30`: Total rounds played over the last 30 maps.\n        - `sum_headshots`: Total headshots over the last 70 maps.\n\n        The `weighted_avg_kills` and `headshot_percentage` are stored in `player_details` for each player\n        \"\"\"\n\n        sum_kills_70 = sum(details[\"kills\"][:70])\n        sum_rounds_70 = sum(details[\"rounds\"][:70])\n        sum_kills_30 = sum(details[\"kills\"][:30])\n        sum_rounds_30 = sum(details[\"rounds\"][:30])\n        sum_headshots = sum(details[\"headshots\"][:70])\n\n        sum_first_x = (sum_kills_70 / sum_rounds_70 * 0.5) if sum_rounds_70 else 0\n        sum_first_y = (sum_kills_30 / sum_rounds_30 * 0.5) if sum_rounds_30 else 0\n        weighted_avg_kills = sum_first_x + sum_first_y\n        player_details[pid][\"weighted_avg_kills\"] = round(weighted_avg_kills, 3)\n\n        headshot_percentage = (sum_headshots / sum_kills_70 * 100) if sum_kills_70 else 0\n        player_details[pid][\"headshots_percentage\"] = round(headshot_percentage, 2)\n\n    players_data = {\"team_id\": team_data[0][\"id\"], \"total_rounds\": total_rounds, \"players\": []}\n    for pid, details in player_details.items():\n        print(details)\n\n        players_data[\"players\"].append({\n            \"player_id\": pid,\n            \"first_name\": details[\"first_name\"],\n            \"last_name\": details[\"last_name\"],\n            \"name\": details[\"name\"],\n            \"player_kills\": sum(details[\"kills\"]),\n            \"player_headshots\": sum(details[\"headshots\"]),\n            \"weighted_avg_kills\": details[\"weighted_avg_kills\"],\n            \"headshots_percentage\": details[\"headshots_percentage\"]\n        })\n    end = time.time()\n    print(f\"It took {end - start} s.\")\n    return players_data",
    "documented_params": [],
    "actual_params": [
      "team_id"
    ],
    "missing_params": [
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "int"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "optimized_fetch_and_aggregate",
    "path": "/team/{team_id}",
    "method": "GET",
    "signature": "team_id: int",
    "docstring": null,
    "description": null,
    "first_lines": "    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()",
    "lineno": 151,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def optimized_fetch_and_aggregate(team_id: int):\n    start = time.time()\n    global REQUEST_COUNT\n    player_games = defaultdict(list)\n    player_details = defaultdict(lambda: {\"kills\": [], \"headshots\": [], \"rounds\": []})\n    unique_game_ids = set()\n\n    api_token = os.getenv(\"PANDASCORE_API_TOKEN\")\n    teams_url = 'https://api.pandascore.co/csgo/teams'\n\n    params_team = {\n        \"filter[id]\": [team_id]\n    }\n    player_games_params = {\n        \"per_page\": 35\n    }\n\n    try:\n        response = requests.get(teams_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                }\n                                , params=params_team)\n        team_data = response.json()\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n    except Exception as e:\n        print(f\"some problem: {e}\")\n\n    for player in team_data[0][\"players\"]:\n        player_id = player[\"id\"]\n        first_name = player.get(\"first_name\", \"\")\n        last_name = player.get(\"last_name\", \"\")\n        nick_name = player.get(\"name\", '')\n        player_details[player_id][\"first_name\"] = first_name\n        player_details[player_id][\"last_name\"] = last_name\n        player_details[player_id][\"name\"] = nick_name\n        player_games_url = f\"https://api.pandascore.co/players/{player_id}/matches?per_page=70&sort=-modified_at\"\n\n        response = requests.get(player_games_url,\n                                headers={\n                                    \"Accept\": \"application/json\",\n                                    \"Authorization\": f\"Bearer {api_token}\"\n                                })\n        REQUEST_COUNT += 1\n        print(f\"REQ CONT: {REQUEST_COUNT}\")\n\n        player_matches = response.json()\n\n        games_collected = 0\n\n        for match in player_matches:\n            for game in match.get('games', []):\n                if games_collected >= 70:\n                    break\n                game_id = game['id']\n                if game_id not in unique_game_ids:\n                    unique_game_ids.add(game_id)\n                    player_games[player_id].append(game_id)\n                    games_collected += 1\n                    '''\n                    if games_collected >= 70:\n                        break\n                    '''\n\n    total_rounds = 0\n    for game_id in unique_game_ids:\n        player_game_stats_url = f\"https://api.pandascore.co/csgo/games/{game_id}\"\n\n        try:\n            response = requests.get(player_game_stats_url,\n                                    headers={\n                                        \"Accept\": \"application/json\",\n                                        \"Authorization\": f\"Bearer {api_token}\"\n                                    })\n            REQUEST_COUNT += 1\n            print(f\"REQ CONT: {REQUEST_COUNT}\")\n            response.raise_for_status()\n            player_game_stats = response.json()\n            rounds_score = player_game_stats.get(\"rounds_score\", [])\n            game_rounds = sum(int(round_info[\"score\"]) for round_info in rounds_score if \"score\" in round_info)\n            total_rounds += game_rounds\n\n            for player_stat in player_game_stats.get('players', []):\n                pid = player_stat['player']['id']\n                if pid in player_games:\n                    kills = player_stat.get('kills', 0)\n                    headshots = player_stat.get(\"headshots\", 0)\n                    player_details[pid][\"kills\"].append(kills)\n                    player_details[pid][\"headshots\"].append(headshots)\n                    player_details[pid][\"rounds\"].append(game_rounds)\n\n        except requests.RequestException as e:\n            print(f\"Failed to fetch player game stats: {e}\")\n\n    for pid, details in player_details.items():\n        \"\"\"\n        This section calculates the weighted average kills (KPR) and headshot percentage for each player over their \n        last 70 and 30 maps played.\n\n        Segments:\n        - The first segment (`x`) considers the last 70 maps.\n        - The second segment (`y`) considers the last 30 maps.\n\n        Calculations:\n        1. `sum_first_x` represents the average kills per round (KPR) for the last 70 maps, weighted by 0.5.\n        2. `sum_first_y` represents the KPR for the last 30 maps, also weighted by 0.5.\n        3. The `weighted_avg_kills` is the sum of `sum_first_x` and `sum_first_y`\n\n        The KPR is rounded to three decimal places, with equal weights (0.5) for statistics from both the 70-map and \n        30-map segments.\n\n        Additionally, the `headshot_percentage` is calculated as the ratio of total headshots to total kills over the \n        last 70 maps, expressed as a percentage.\n\n        Calculations:\n        - `sum_kills_70`: Total kills over the last 70 maps.\n        - `sum_rounds_70`: Total rounds played over the last 70 maps.\n        - `sum_kills_30`: Total kills over the last 30 maps.\n        - `sum_rounds_30`: Total rounds played over the last 30 maps.\n        - `sum_headshots`: Total headshots over the last 70 maps.\n\n        The `weighted_avg_kills` and `headshot_percentage` are stored in `player_details` for each player\n        \"\"\"\n\n        sum_kills_70 = sum(details[\"kills\"][:70])\n        sum_rounds_70 = sum(details[\"rounds\"][:70])\n        sum_kills_30 = sum(details[\"kills\"][:30])\n        sum_rounds_30 = sum(details[\"rounds\"][:30])\n        sum_headshots = sum(details[\"headshots\"][:70])\n\n        sum_first_x = (sum_kills_70 / sum_rounds_70 * 0.5) if sum_rounds_70 else 0\n        sum_first_y = (sum_kills_30 / sum_rounds_30 * 0.5) if sum_rounds_30 else 0\n        weighted_avg_kills = sum_first_x + sum_first_y\n        player_details[pid][\"weighted_avg_kills\"] = round(weighted_avg_kills, 3)\n\n        headshot_percentage = (sum_headshots / sum_kills_70 * 100) if sum_kills_70 else 0\n        player_details[pid][\"headshots_percentage\"] = round(headshot_percentage, 2)\n\n    players_data = {\"team_id\": team_data[0][\"id\"], \"total_rounds\": total_rounds, \"players\": []}\n    for pid, details in player_details.items():\n        print(details)\n\n        players_data[\"players\"].append({\n            \"player_id\": pid,\n            \"first_name\": details[\"first_name\"],\n            \"last_name\": details[\"last_name\"],\n            \"name\": details[\"name\"],\n            \"player_kills\": sum(details[\"kills\"]),\n            \"player_headshots\": sum(details[\"headshots\"]),\n            \"weighted_avg_kills\": details[\"weighted_avg_kills\"],\n            \"headshots_percentage\": details[\"headshots_percentage\"]\n        })\n    end = time.time()\n    print(f\"It took {end - start} s.\")\n    return players_data",
    "documented_params": [],
    "actual_params": [
      "team_id"
    ],
    "missing_params": [
      "team_id"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "team_id": "int"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['team_id']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "router",
    "qualname": "predict_stats",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    players_data = data.get(\"players\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2",
    "lineno": 311,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def predict_stats(request: Request):\n    data = await request.json()\n    players_data = data.get(\"players\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2\n    predicted_kills_team2_map1 = float(data.get(\"predicted_kills_team2_map1\", 0)) / 2\n    predicted_kills_team1_map2 = float(data.get(\"predicted_kills_team1_map2\", 0)) / 2\n    predicted_kills_team2_map2 = float(data.get(\"predicted_kills_team2_map2\", 0)) / 2\n\n    results = []\n    for index, player in enumerate(players_data):\n        if index < 5:  # Player is in team1\n            team_sum_kills = sum_kills_team1\n            team_predicted_kills_map1 = predicted_kills_team1_map1\n            team_predicted_kills_map2 = predicted_kills_team1_map2\n        else:  # Player is in team2\n            team_sum_kills = sum_kills_team2\n            team_predicted_kills_map1 = predicted_kills_team2_map1\n            team_predicted_kills_map2 = predicted_kills_team2_map2\n\n        proportion = player[\"avg_weighted_kills\"] / team_sum_kills if team_sum_kills > 0 else 0\n\n        predicted_kills_map1 = proportion * team_predicted_kills_map1\n        predicted_kills_map2 = proportion * team_predicted_kills_map2\n\n        total_predicted_kills = predicted_kills_map1 + predicted_kills_map2\n\n        hs_percentage = player[\"hs_percentage\"] / 100\n        predicted_hs_map1 = predicted_kills_map1 * hs_percentage\n        predicted_hs_map2 = predicted_kills_map2 * hs_percentage\n        total_predicted_hs = total_predicted_kills * hs_percentage\n\n        results.append({\n            \"player_name\": player[\"player_name\"],\n            \"predicted_kills_map1\": round(predicted_kills_map1, 2),\n            \"predicted_hs_map1\": round(predicted_hs_map1, 2),\n            \"predicted_kills_map2\": round(predicted_kills_map2, 2),\n            \"predicted_hs_map2\": round(predicted_hs_map2, 2),\n            \"total_predicted_kills\": round(total_predicted_kills, 2),\n            \"total_predicted_hs\": round(total_predicted_hs, 2),\n        })\n\n    return JSONResponse({\"results\": results})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "predict_stats",
    "path": "/predict-stats",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    players_data = data.get(\"players\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2",
    "lineno": 311,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def predict_stats(request: Request):\n    data = await request.json()\n    players_data = data.get(\"players\", [])\n    sum_kills_team1 = float(data.get(\"sum_kills_team1\", 0))\n    sum_kills_team2 = float(data.get(\"sum_kills_team2\", 0))\n    predicted_kills_team1_map1 = float(data.get(\"predicted_kills_team1_map1\", 0)) / 2\n    predicted_kills_team2_map1 = float(data.get(\"predicted_kills_team2_map1\", 0)) / 2\n    predicted_kills_team1_map2 = float(data.get(\"predicted_kills_team1_map2\", 0)) / 2\n    predicted_kills_team2_map2 = float(data.get(\"predicted_kills_team2_map2\", 0)) / 2\n\n    results = []\n    for index, player in enumerate(players_data):\n        if index < 5:  # Player is in team1\n            team_sum_kills = sum_kills_team1\n            team_predicted_kills_map1 = predicted_kills_team1_map1\n            team_predicted_kills_map2 = predicted_kills_team1_map2\n        else:  # Player is in team2\n            team_sum_kills = sum_kills_team2\n            team_predicted_kills_map1 = predicted_kills_team2_map1\n            team_predicted_kills_map2 = predicted_kills_team2_map2\n\n        proportion = player[\"avg_weighted_kills\"] / team_sum_kills if team_sum_kills > 0 else 0\n\n        predicted_kills_map1 = proportion * team_predicted_kills_map1\n        predicted_kills_map2 = proportion * team_predicted_kills_map2\n\n        total_predicted_kills = predicted_kills_map1 + predicted_kills_map2\n\n        hs_percentage = player[\"hs_percentage\"] / 100\n        predicted_hs_map1 = predicted_kills_map1 * hs_percentage\n        predicted_hs_map2 = predicted_kills_map2 * hs_percentage\n        total_predicted_hs = total_predicted_kills * hs_percentage\n\n        results.append({\n            \"player_name\": player[\"player_name\"],\n            \"predicted_kills_map1\": round(predicted_kills_map1, 2),\n            \"predicted_hs_map1\": round(predicted_hs_map1, 2),\n            \"predicted_kills_map2\": round(predicted_kills_map2, 2),\n            \"predicted_hs_map2\": round(predicted_hs_map2, 2),\n            \"total_predicted_kills\": round(total_predicted_kills, 2),\n            \"total_predicted_hs\": round(total_predicted_hs, 2),\n        })\n\n    return JSONResponse({\"results\": results})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "router",
    "qualname": "generate_h2h_data",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")",
    "lineno": 358,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def generate_h2h_data(request: Request):\n    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")\n\n    player_dict_list = []\n    precomputed_probs = {player: poisson_probabilities(players_data[player][\"sumPredictedKills\"]) for player in\n                         players_data}\n\n    for player1, player2 in combinations(players_data.keys(), 2):\n        prob_matrix = create_probability_matrix(precomputed_probs[player1], precomputed_probs[player2])\n        prob_a_wins, prob_draw, prob_b_wins = calculate_total_probabilities(prob_matrix)\n\n        if data.get('with_draw'):\n            odds_a_wins, odds_b_wins, odds_draw = calculate_odds(prob_a_wins, prob_b_wins, margin, prob_draw)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)},\n                \"draw\": {\"odds\": round(odds_draw, 2)},\n            })\n        else:\n            odds_a_wins, odds_b_wins = calculate_odds(prob_a_wins, prob_b_wins, margin)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)}\n            })\n\n    return JSONResponse(content={\"h2h\": player_dict_list})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "generate_h2h_data",
    "path": "/generate-h2h-data",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")",
    "lineno": 358,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def generate_h2h_data(request: Request):\n    data = await request.json()\n    margin = data.get(\"margin\", 1.08)  # Default margin\n    players_data = data.get(\"players\")\n    if not players_data or not margin:\n        raise HTTPException(status_code=400, detail=\"Missing or invalid data in the request\")\n\n    player_dict_list = []\n    precomputed_probs = {player: poisson_probabilities(players_data[player][\"sumPredictedKills\"]) for player in\n                         players_data}\n\n    for player1, player2 in combinations(players_data.keys(), 2):\n        prob_matrix = create_probability_matrix(precomputed_probs[player1], precomputed_probs[player2])\n        prob_a_wins, prob_draw, prob_b_wins = calculate_total_probabilities(prob_matrix)\n\n        if data.get('with_draw'):\n            odds_a_wins, odds_b_wins, odds_draw = calculate_odds(prob_a_wins, prob_b_wins, margin, prob_draw)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)},\n                \"draw\": {\"odds\": round(odds_draw, 2)},\n            })\n        else:\n            odds_a_wins, odds_b_wins = calculate_odds(prob_a_wins, prob_b_wins, margin)\n            player_dict_list.append({\n                \"player1\": {\"name\": player1, \"odds\": round(odds_a_wins, 2)},\n                \"player2\": {\"name\": player2, \"odds\": round(odds_b_wins, 2)}\n            })\n\n    return JSONResponse(content={\"h2h\": player_dict_list})",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [
      "HTTPException"
    ],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "router",
    "qualname": "generate_over_under_data",
    "path": "",
    "method": "ASYNC_FUNCTION",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)",
    "lineno": 391,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def generate_over_under_data(request: Request):\n    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)\n\n        odds_data = []\n        for predictedKillsData in data.get(\"predictedKills\", []):\n            player_odds = {}\n            player = predictedKillsData.get(\"player\", {})\n            player_odds[\"player\"] = player\n            player_map1_prediction = predictedKillsData.get(\"map1\", {})\n            predicted_kills_map1 = player_map1_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_1\"] = calculate_odds(predicted_kills_map1, margin)\n            player_map2_prediction = predictedKillsData.get(\"map2\", {})\n            predicted_kills_map2 = player_map2_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_2\"] = calculate_odds(predicted_kills_map2, margin)\n            total_kills = predicted_kills_map1 + predicted_kills_map2\n            player_odds[\"total_kills\"] = calculate_odds(total_kills, margin)\n            odds_data.append(player_odds)\n\n        return JSONResponse(content={\"odds_data\": odds_data, \"margin_error\": margin_error})\n\n    except json.JSONDecodeError:\n        return HTTPException(status_code=400, detail=\"Invalid JSON\")",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "router",
    "qualname": "generate_over_under_data",
    "path": "/generate-over-under-data",
    "method": "POST",
    "signature": "request: Request",
    "docstring": null,
    "description": null,
    "first_lines": "    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)",
    "lineno": 391,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/app/api/cs2/router.py",
    "full_source": "async def generate_over_under_data(request: Request):\n    try:\n        data = await request.json()\n        margin, margin_error = get_margin(data)\n        if margin_error:\n            return JSONResponse(content={\"margin_error\": margin_error}, status_code=400)\n\n        odds_data = []\n        for predictedKillsData in data.get(\"predictedKills\", []):\n            player_odds = {}\n            player = predictedKillsData.get(\"player\", {})\n            player_odds[\"player\"] = player\n            player_map1_prediction = predictedKillsData.get(\"map1\", {})\n            predicted_kills_map1 = player_map1_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_1\"] = calculate_odds(predicted_kills_map1, margin)\n            player_map2_prediction = predictedKillsData.get(\"map2\", {})\n            predicted_kills_map2 = player_map2_prediction.get(\"kills\", 0.0)\n            player_odds[\"map_2\"] = calculate_odds(predicted_kills_map2, margin)\n            total_kills = predicted_kills_map1 + predicted_kills_map2\n            player_odds[\"total_kills\"] = calculate_odds(total_kills, margin)\n            odds_data.append(player_odds)\n\n        return JSONResponse(content={\"odds_data\": odds_data, \"margin_error\": margin_error})\n\n    except json.JSONDecodeError:\n        return HTTPException(status_code=400, detail=\"Invalid JSON\")",
    "documented_params": [],
    "actual_params": [
      "request"
    ],
    "missing_params": [
      "request"
    ],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {
      "request": "Request"
    },
    "return_type": null,
    "has_type_hints": true,
    "coverage_score": 30.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing parameter docs: ['request']"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 45.0,
    "maintainability_score": 50.0,
    "api_completeness_score": 56.0
  },
  {
    "module": "tests_models",
    "qualname": "test_league_model",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    league_data = {\n        \"id\": 1,\n        \"name\": \"Test League\",\n        \"slug\": \"test-league\",\n        \"modified_at\": datetime.utcnow(),",
    "lineno": 12,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/tests/tests_models.py",
    "full_source": "def test_league_model():\n    league_data = {\n        \"id\": 1,\n        \"name\": \"Test League\",\n        \"slug\": \"test-league\",\n        \"modified_at\": datetime.utcnow(),\n        \"image_url\": \"http://example.com/image.png\",\n        \"url\": \"http://example.com\"\n    }\n\n    league = League(**league_data)\n\n    assert league.id == 1\n    assert league.name == \"Test League\"\n    assert league.image_url is not None\n\n    # Test model conversion to dictionary\n    league_dict = league.model_dump()\n    assert league_dict[\"name\"] == league_data[\"name\"]\n\n    # Test validation failure\n    with pytest.raises(ValidationError):\n        invalid_data = league_data.copy()\n        invalid_data[\"id\"] = \"not an integer\"  # Invalid id\n        League(**invalid_data)",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "tests_models",
    "qualname": "test_serie_model",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    serie_data = {\n        \"id\": 1,\n        \"begin_at\": datetime.utcnow(),\n        \"end_at\": datetime.utcnow(),\n        \"full_name\": \"Test Serie\",",
    "lineno": 38,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/tests/tests_models.py",
    "full_source": "def test_serie_model():\n    serie_data = {\n        \"id\": 1,\n        \"begin_at\": datetime.utcnow(),\n        \"end_at\": datetime.utcnow(),\n        \"full_name\": \"Test Serie\",\n        \"league_id\": 1,\n        \"modified_at\": datetime.utcnow(),\n        \"name\": \"Test Serie\",\n        \"slug\": \"test-serie\",\n        \"year\": 2020,\n        \"season\": None,\n        \"winner_id\": None,\n        \"winner_type\": None\n    }\n\n    serie = Serie(**serie_data)\n\n    assert serie.full_name == \"Test Serie\"\n    assert serie.year == 2020",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "tests_models",
    "qualname": "test_team_model",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": null,
    "description": null,
    "first_lines": "    team_data = {\n        \"id\": 1,\n        \"name\": \"Test Team\",\n        \"slug\": \"test-team\",\n        \"modified_at\": datetime.utcnow(),",
    "lineno": 59,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/tests/tests_models.py",
    "full_source": "def test_team_model():\n    team_data = {\n        \"id\": 1,\n        \"name\": \"Test Team\",\n        \"slug\": \"test-team\",\n        \"modified_at\": datetime.utcnow(),\n        \"acronym\": \"TT\",\n        \"location\": \"Test City\",\n        \"image_url\": \"http://example.com/team.png\"\n    }\n\n    team = Team(**team_data)\n\n    assert team.name == \"Test Team\"\n    assert team.acronym == \"TT\"",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": null,
    "has_type_hints": false,
    "coverage_score": 60.0,
    "quality_score": 0.0,
    "completeness_issues": [
      "Missing docstring",
      "Missing type hints"
    ],
    "docstring_style": null,
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 0,
    "complexity_score": 100,
    "maintainability_score": 67.5,
    "api_completeness_score": 0.0
  },
  {
    "module": "env",
    "qualname": "run_migrations_offline",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": "Run migrations in 'offline' mode.\n\nThis configures the context with just a URL\nand not an Engine, though an Engine is acceptable\nhere as well.  By skipping the Engine creation,\nwe don't even need a DBAPI to be available.\n\nCalls to context.execute() here emit the given string to the\nscript output.",
    "description": null,
    "first_lines": "    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation,",
    "lineno": 34,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/alembic/env.py",
    "full_source": "def run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation,\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 100.0,
    "quality_score": 50.0,
    "completeness_issues": [],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 297,
    "complexity_score": 80.0,
    "maintainability_score": 90.0,
    "api_completeness_score": 0.0
  },
  {
    "module": "env",
    "qualname": "run_migrations_online",
    "path": "",
    "method": "FUNCTION",
    "signature": "",
    "docstring": "Run migrations in 'online' mode.\n\nIn this scenario, we need to create an Engine\nand associate a connection with the context.",
    "description": null,
    "first_lines": "    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario, we need to create an Engine\n    and associate a connection with the context.\n",
    "lineno": 58,
    "file_path": "/Users/bartoszkobylinski/Programming/Python/eppop_fast_api/alembic/env.py",
    "full_source": "def run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario, we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()",
    "documented_params": [],
    "actual_params": [],
    "missing_params": [],
    "extra_params": [],
    "has_return_doc": false,
    "param_types": {},
    "return_type": "None",
    "has_type_hints": true,
    "coverage_score": 100.0,
    "quality_score": 50.0,
    "completeness_issues": [],
    "docstring_style": "plain",
    "style_issues": [],
    "documented_exceptions": [],
    "raised_exceptions": [],
    "has_exception_doc": false,
    "response_model": null,
    "status_codes": [],
    "response_description": null,
    "dependencies": [],
    "dependency_docs": {},
    "tags": [],
    "operation_id": null,
    "summary_from_decorator": null,
    "docstring_length": 124,
    "complexity_score": 80.0,
    "maintainability_score": 90.0,
    "api_completeness_score": 0.0
  }
]